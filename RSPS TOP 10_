# Majors Top-10 Screener â€” Safe Mode (Auto-open in Google Chrome)
# Backtest (2025-01-01 â†’ today) vs BTC + Table PNG + optional HTML/CSV
# Universe: BTC, ETH, BNB, SOL, XRP, ADA, DOGE, TON, TRX, LINK

import os, sys, time, math, random, shutil, webbrowser, subprocess
from datetime import datetime, date
import numpy as np
import pandas as pd
import requests
import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle

# ============================= CONFIG =============================
LOOKBACK_START   = "2020-01-01"
BACKTEST_START   = "2025-01-01"
BACKTEST_END     = None

TOP_K_DOLLAR_VOL = 25
ROLL_VOL_DAYS    = 14

ENTRY_OK_THRESHOLD = 60.0
BREADTH_MIN        = 20.0
BREADTH_FULL       = 50.0
CONF_BLEND_ENTRY   = 0.50
CONF_EXPONENT      = 1.25
MAX_WEIGHT_PCT     = 25.0
MIN_SHOW_WEIGHT    = 0.25

OUT_BACKTEST_PNG = "majors_rsps_backtest_vs_btc.png"
OUT_TABLE_PNG    = "majors_screener_table.png"
OUT_HTML         = "majors_screener_daily.html"
OUT_CSV          = "majors_screener_daily.csv"
WRITE_HTML_CSV   = True
OPEN_IN_CHROME   = True

CRYPTOCOMPARE_API_KEY = os.getenv("CRYPTOCOMPARE_API_KEY", "").strip()
EXCHANGES_TRY = ["BINANCE","BYBIT","OKX","KUCOIN","BITGET","GATEIO","KRAKEN","COINBASE", None]
PAIR_CACHE = {}
MAX_RETRIES = 6
BASE_SLEEP  = 1.0
SESSION     = requests.Session()

np.set_printoptions(suppress=True)
pd.set_option("display.width", 180)
pd.set_option("display.max_columns", 50)

MAJORS = ["BTC","ETH","BNB","SOL","XRP","ADA","DOGE","TON","TRX","LINK"]

# ============================= COLORS (match screenshot) =============================
C_BG_EVEN   = "#1b1b1b"
C_BG_ODD    = "#202020"
C_HDR       = "#0b0b0b"
C_TEXT      = "#dddddd"
C_TEXT_HDR  = "#ffffff"

C_POS_BASE  = "#10361e"   # base green cell
C_NEG_BASE  = "#3a1515"   # base red cell
C_POS_EDGE  = "#1f6b3a"
C_NEG_EDGE  = "#7a2a2a"

C_BUY       = "#1fa971"
C_HOLD      = "#dca408"
C_SELL      = "#d14b41"
C_NOTRADE   = "#555555"

C_RISK_ON   = "#0f7d4f"
C_RISK_OFF  = "#943233"

C_BAR_GREEN = "#2fb66f"
C_BAR_GRAY  = "#8a8a8a"

# ============================= UTILS =============================
def log(msg): print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] {msg}")

def open_in_chrome(html_path: str):
    url = f"file://{os.path.abspath(html_path)}"
    if sys.platform == "darwin":
        try:
            subprocess.Popen(["/usr/bin/open", "-a", "Google Chrome", url])
            log("Opened with: open -a 'Google Chrome'")
            return
        except Exception as e:
            log(f"macOS Chrome open failed: {e}")
    candidates = [
        "google-chrome","google-chrome-stable","chrome","chromium","chromium-browser",
        r"C:\Program Files\Google\Chrome\Application\chrome.exe",
        r"C:\Program Files (x86)\Google\Chrome\Application\chrome.exe",
        "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome",
    ]
    def path_if_exists(p):
        return p if (p and os.path.isabs(p) and os.path.exists(p)) else None
    for c in candidates:
        p = path_if_exists(c)
        if p:
            try:
                webbrowser.get(f'"{p}" %s').open(url, new=2); log(f"Opened in Chrome: {p}"); return
            except Exception as e:
                log(f"Chrome exec open failed ({p}): {e}")
    for c in candidates:
        if os.path.isabs(c): continue
        exe = shutil.which(c)
        if not exe: continue
        try:
            webbrowser.get(f'"{exe}" %s').open(url, new=2); log(f"Opened in Chrome: {exe}"); return
        except Exception as e:
            log(f"Chrome exec open failed ({exe}): {e}")
    if sys.platform.startswith("win"):
        try:
            os.startfile(url); log("Opened with Windows default handler."); return  # type: ignore[attr-defined]
        except Exception as e:
            log(f"Windows startfile failed: {e}")
    if sys.platform.startswith("linux"):
        try:
            subprocess.Popen(["xdg-open", url]); log("Opened with xdg-open fallback."); return
        except Exception as e:
            log(f"xdg-open failed: {e}")
    log("Chrome not found; falling back to default browser."); webbrowser.open(url, new=2)

def cc_headers():
    return {"authorization": f"Apikey {CRYPTOCOMPARE_API_KEY}"} if CRYPTOCOMPARE_API_KEY else {}

def _is_no_market(j) -> bool:
    msg = (j or {}).get("Message","").lower()
    return any(k in msg for k in ["market does not exist","pair not found","there is no data"])

def cc_histoday_page_with(sym, tsym="USD", exchange=None, limit=2000, toTs=None):
    url = "https://min-api.cryptocompare.com/data/v2/histoday"
    params = {"fsym": sym, "tsym": tsym, "limit": min(2000, limit)}
    if toTs is not None: params["toTs"] = int(toTs)
    if exchange: params["e"] = exchange
    headers = cc_headers()
    last_err = None
    for k in range(MAX_RETRIES):
        try:
            r = SESSION.get(url, params=params, headers=headers, timeout=30)
            if r.status_code == 429:
                wait = BASE_SLEEP*(2**k) + random.uniform(0,0.6)
                log(f"429 {sym}-{tsym}@{exchange or 'CCCAGG'}; sleep {wait:.1f}s"); time.sleep(wait); continue
            r.raise_for_status()
            data = r.json()
            if data.get("Response") != "Success":
                if _is_no_market(data): return None
                last_err = RuntimeError(data.get("Message","Unknown CC error"))
                wait = BASE_SLEEP*(2**k) + random.uniform(0,0.6)
                log(f"CC bad resp {sym}-{tsym}@{exchange}: {last_err} (retry {k+1}/{MAX_RETRIES}, {wait:.1f}s)")
                time.sleep(wait); continue
            df = pd.DataFrame(data["Data"]["Data"])
            if df.empty: return pd.DataFrame()
            df["Date"] = pd.to_datetime(df["time"], unit="s", utc=True).dt.tz_convert("UTC").dt.tz_localize(None)
            df = df.set_index("Date").rename(columns={
                "open":"Open","high":"High","low":"Low","close":"Close",
                "volumefrom":"VolumeFrom","volumeto":"VolumeTo"
            })
            return df
        except Exception as e:
            last_err = e
            wait = BASE_SLEEP*(2**k) + random.uniform(0,0.6)
            log(f"CC error {sym}-{tsym}@{exchange}: {e} (retry {k+1}/{MAX_RETRIES}, {wait:.1f}s)")
            time.sleep(wait)
    raise RuntimeError(f"Failed CC histoday for {sym}-{tsym}@{exchange}: {last_err}")

def cc_histoday_full_with(sym, tsym="USD", exchange=None, start="2020-01-01"):
    target = pd.to_datetime(start)
    df = cc_histoday_page_with(sym, tsym=tsym, exchange=exchange, limit=2000)
    if df is None or df.empty: return pd.DataFrame()
    df = df.sort_index()
    earliest = df.index.min()
    while earliest > target:
        toTs = int(earliest.timestamp()) - 86400
        older = cc_histoday_page_with(sym, tsym=tsym, exchange=exchange, limit=2000, toTs=toTs)
        if older is None or older.empty: break
        df = pd.concat([older, df], axis=0)
        df = df[~df.index.duplicated(keep="first")].sort_index()
        earliest = df.index.min()
        time.sleep(0.08)
    return df[df.index >= pd.to_datetime(start)]

def resolve_pair_and_fetch(sym, start="2020-01-01"):
    if sym in PAIR_CACHE:
        conf = PAIR_CACHE[sym]; return cc_histoday_full_with(sym, conf["tsym"], conf["e"], start), conf
    for tsym in ("USD","USDT"):
        for ex in EXCHANGES_TRY:
            df0 = cc_histoday_page_with(sym, tsym=tsym, exchange=ex, limit=2000)
            if df0 is None: continue
            if isinstance(df0, pd.DataFrame) and not df0.empty:
                df_full = cc_histoday_full_with(sym, tsym, ex, start)
                PAIR_CACHE[sym] = {"tsym": tsym, "e": ex}
                tag = ex or "CCCAGG"
                log(f"OK {sym}-{tsym}@{tag}: {len(df_full)} rows")
                return df_full, PAIR_CACHE[sym]
    log(f"UNSUPPORTED on CC: {sym} (skipping)")
    return pd.DataFrame(), None

def get_ohlcv(symbol, start="2020-01-01"):
    df, _ = resolve_pair_and_fetch(symbol, start=start); return df

# ============================= INDICATORS =============================
def ema(s, n): return s.ewm(span=n, adjust=False).mean()

def rsi(series, length=14):
    s = series.astype(float); d = s.diff()
    up = np.where(d > 0, d, 0.0); dn = np.where(d < 0, -d, 0.0)
    up_ewm = pd.Series(up, index=s.index).ewm(alpha=1/length, adjust=False).mean()
    dn_ewm = pd.Series(dn, index=s.index).ewm(alpha=1/length, adjust=False).mean()
    rs = up_ewm / (dn_ewm.replace(0, np.nan))
    return (100 - (100 / (1 + rs))).fillna(0)

def sharpe(r, ppy=365):
    r = r.dropna()
    if r.empty: return 0.0
    sd = r.std(ddof=0)
    return 0.0 if sd==0 or np.isnan(sd) else (r.mean()/sd)*math.sqrt(ppy)

# ============================= DATA ALIGNMENT =============================
def load_universe(symbols, start):
    frames, failed = {}, []
    for sym in symbols:
        try:
            df = get_ohlcv(sym, start=start)
            if df is None or df.empty: failed.append(sym); continue
            frames[sym] = df; time.sleep(0.05)
        except Exception as e:
            failed.append(sym); log(f"FAIL {sym}: {e}")
    if failed: log(f"Skipped (no market / error): {failed}")
    if not frames: raise RuntimeError("No symbols had valid markets on CryptoCompare.")
    return frames

def align_panel(frames):
    all_idx = None
    for df in frames.values():
        all_idx = df.index if all_idx is None else all_idx.union(df.index)
    all_idx = all_idx.sort_values(); cols = list(frames.keys())
    C = pd.DataFrame(index=all_idx, columns=cols, dtype=float)
    H = pd.DataFrame(index=all_idx, columns=cols, dtype=float)
    L = pd.DataFrame(index=all_idx, columns=cols, dtype=float)
    V = pd.DataFrame(index=all_idx, columns=cols, dtype=float)
    VT= pd.DataFrame(index=all_idx, columns=cols, dtype=float)
    for sym, df in frames.items():
        C.loc[df.index, sym]  = df["Close"].astype(float)
        H.loc[df.index, sym]  = df["High"].astype(float)
        L.loc[df.index, sym]  = df["Low"].astype(float)
        V.loc[df.index, sym]  = df["VolumeFrom"].astype(float)
        VT.loc[df.index, sym] = df["VolumeTo"].astype(float)
    return C,H,L,V,VT

# ============================= CORE LOGIC HELPERS =============================
def exposure_from_breadth(breadth_pct, bmin=BREADTH_MIN, bfull=BREADTH_FULL):
    if bfull <= bmin: return 0.0
    x = (breadth_pct - bmin) / (bfull - bmin)
    return float(np.clip(x, 0.0, 1.0))

def entry_checks_for_day(idx, C,H,L,V, ema20,ema50, rsi3,rsi14, r7, r10, sh7, ema_diff):
    checks = {}
    checks[">EMA20"]   = (C.loc[idx] > ema20.loc[idx])
    checks["RSI3>55"]  = (rsi3.loc[idx] > 55)
    checks["RSI14>50"] = (rsi14.loc[idx] > 50)
    checks["ROC10>0"]  = (r10.loc[idx] > 0)
    checks["7d>0"]     = (r7.loc[idx]  > 0)
    checks["Sharpe+"]  = (sh7.loc[idx] > 0)
    checks["EMA+"]     = (ema_diff.loc[idx] > 0)
    df = pd.DataFrame(checks)
    entry_pct = df.mean(axis=1) * 100.0
    return df, entry_pct

def compute_score_parts(idx, df_day):
    def pct_rank(s):
        s = pd.Series(s).replace([np.inf,-np.inf], np.nan)
        return s.rank(pct=True, method="average")
    w = {"r7":0.18,"r14":0.18,"mom":0.18,"rsi_med":0.14,"sh7":0.14,"ema":0.12,"voltr":0.06}
    parts = {
        "r7": pct_rank(df_day["7d Return"]),
        "r14": pct_rank(df_day["14d Return"]),
        "mom": pct_rank(df_day["Momentum"]),
        "rsi_med": pct_rank(df_day["RSI Med"]),
        "sh7": pct_rank(df_day["Sharpe 7d"]),
        "ema": pct_rank(df_day["EMA Diff"]),
        "voltr": pct_rank(df_day["Vol. Trend"])
    }
    score = sum(parts[k]*w[k] for k in w) * 100.0
    return score

# ============================= SCREENER (today) =============================
def build_table_today(C,H,L,V,VT):
    ret1 = C.pct_change()
    r3  = C.pct_change(3);  r7  = C.pct_change(7);  r14 = C.pct_change(14)
    r10 = C.pct_change(10)
    rsi3  = C.apply(lambda s: rsi(s, 3));  rsi14 = C.apply(lambda s: rsi(s,14))
    ema20 = C.apply(lambda s: ema(s,20));  ema50 = C.apply(lambda s: ema(s,50))
    v7 = V.rolling(7).mean(); v28 = V.rolling(28).mean(); vol_trend = (v7/v28 - 1.0)
    sh7 = ret1.rolling(7).apply(lambda x: sharpe(pd.Series(x)), raw=False)
    ema_diff = (C/ema50 - 1.0) * 100.0
    dv14 = VT.rolling(ROLL_VOL_DAYS).sum()

    today = C.index[-1]; yday = C.index[-2] if len(C.index) >= 2 else today

    dv_today = dv14.loc[today].dropna().sort_values(ascending=False)
    top_syms = list(dv_today.index[:min(TOP_K_DOLLAR_VOL, len(dv_today))])
    if not top_syms: raise RuntimeError("No symbols have dollar-volume; check API responses.")

    _, entry_pct_today = entry_checks_for_day(today, C,H,L,V, ema20,ema50, rsi3,rsi14, r7, r10, sh7, ema_diff)
    _, entry_pct_prev  = entry_checks_for_day(yday,  C,H,L,V, ema20,ema50, rsi3,rsi14, r7, r10, sh7, ema_diff)

    entry_pct_today = entry_pct_today.reindex(top_syms)
    entry_pct_prev  = entry_pct_prev.reindex(top_syms)

    coin_risk = np.where(entry_pct_today >= ENTRY_OK_THRESHOLD, "RISK_ON", "RISK_OFF")

    df = pd.DataFrame(index=top_syms)
    df["Token"]      = [sym + "USDT" for sym in top_syms]
    df["3d Return"]  = r3.loc[today, top_syms].values * 100
    df["7d Return"]  = r7.loc[today, top_syms].values * 100
    df["14d Return"] = r14.loc[today, top_syms].values * 100
    df["RSI Short"]  = rsi3.loc[today, top_syms].values
    df["RSI Med"]    = rsi14.loc[today, top_syms].values
    df["Vol. Trend"] = vol_trend.loc[today, top_syms].values
    df["Momentum"]   = r10.loc[today, top_syms].values
    df["Sharpe 7d"]  = sh7.loc[today, top_syms].values
    df["EMA Diff"]   = ema_diff.loc[today, top_syms].values
    df["Close"]      = C.loc[today, top_syms].values
    df["Entry %"]    = entry_pct_today.values
    df["Risk Gauge"] = coin_risk

    df["Score"] = compute_score_parts(today, df).values
    conf = CONF_BLEND_ENTRY*df["Entry %"].clip(0,100) + (1.0-CONF_BLEND_ENTRY)*df["Score"].clip(0,100)
    df["Confidence %"] = conf.values

    prev_pass = (entry_pct_prev >= ENTRY_OK_THRESHOLD).fillna(False)
    curr_pass = (entry_pct_today >= ENTRY_OK_THRESHOLD).fillna(False)
    signal = np.where(curr_pass & ~prev_pass, "BUY",
                      np.where(curr_pass & prev_pass, "HOLD",
                               np.where(~curr_pass & prev_pass, "SELL", "NO TRADE")))
    df["Signal"] = signal

    breadth_pct = float((df["Entry %"] >= ENTRY_OK_THRESHOLD).mean()*100.0)
    exposure = exposure_from_breadth(breadth_pct)

    eligible = (df["Risk Gauge"] == "RISK_ON")
    raw = pd.Series(0.0, index=df.index)
    if eligible.any():
        raw_elig = (df.loc[eligible, "Confidence %"] / 100.0) ** CONF_EXPONENT
        raw_elig = raw_elig / raw_elig.sum() if raw_elig.sum() > 0 else raw_elig
        wts = (raw_elig * 100.0).clip(0, MAX_WEIGHT_PCT)
        total = wts.sum()
        if total > 0: wts = wts * (100.0 / total)
        raw.loc[wts.index] = wts.values
    final_w = (raw * (exposure * 100.0)).where(lambda s: s >= MIN_SHOW_WEIGHT, 0.0)
    df["Suggested Wt %"] = final_w.values

    df = df.sort_values(by=["Confidence %","Score","Entry %"], ascending=False)
    df.insert(0, "Rank", range(1, len(df)+1))

    pct_cols = ["3d Return","7d Return","14d Return","EMA Diff","Entry %","Score","Confidence %","Suggested Wt %"]
    for c in pct_cols:
        if c in df.columns: df[c] = df[c].round(2)
    for c in ["RSI Short","RSI Med","Sharpe 7d","Momentum","Vol. Trend","Close"]:
        if c in df.columns: df[c] = df[c].round(2)

    meta = {"today": today, "breadth": breadth_pct, "exposure": exposure, "alloc_sum": float(df["Suggested Wt %"].sum())}
    df = df[["Rank","Token","Signal","Score","Entry %","Risk Gauge","3d Return","7d Return","14d Return",
             "RSI Short","RSI Med","Vol. Trend","Momentum","Sharpe 7d","EMA Diff","Close","Confidence %","Suggested Wt %"]]
    return df, meta

# ============================= BACKTEST =============================
def backtest(C,H,L,V,VT, start=None, end=None):
    ret1 = C.pct_change()
    r7  = C.pct_change(7);  r14 = C.pct_change(14);  r10 = C.pct_change(10)
    rsi3  = C.apply(lambda s: rsi(s, 3));  rsi14 = C.apply(lambda s: rsi(s,14))
    ema20 = C.apply(lambda s: ema(s,20));  ema50 = C.apply(lambda s: ema(s,50))
    v7 = V.rolling(7).mean(); v28 = V.rolling(28).mean()
    sh7 = ret1.rolling(7).apply(lambda x: sharpe(pd.Series(x)), raw=False)
    ema_diff = (C/ema50 - 1.0) * 100.0
    dv14 = VT.rolling(ROLL_VOL_DAYS).sum()

    dates = C.index
    if start: dates = dates[dates >= pd.to_datetime(start)]
    if end:   dates = dates[dates <= pd.to_datetime(end)]
    if len(dates) < 30: raise RuntimeError("Backtest window too short.")

    equity = pd.Series(index=dates, dtype=float); equity.iloc[0] = 1.0

    for i in range(1, len(dates)):
        d = dates[i]
        dv_today = dv14.loc[d].dropna().sort_values(ascending=False)
        top = list(dv_today.index[:min(TOP_K_DOLLAR_VOL, len(dv_today))])

        df_day = pd.DataFrame(index=top)
        df_day["7d Return"]  = r7.loc[d, top].values * 100
        df_day["14d Return"] = r14.loc[d, top].values * 100
        df_day["Momentum"]   = r10.loc[d, top].values
        df_day["RSI Med"]    = rsi14.loc[d, top].values
        df_day["Sharpe 7d"]  = sh7.loc[d, top].values
        df_day["EMA Diff"]   = ema_diff.loc[d, top].values
        df_day["Vol. Trend"] = (v7.loc[d, top] / v28.loc[d, top] - 1.0).values

        _, entry_today = entry_checks_for_day(d, C,H,L,V, ema20,ema50, rsi3,rsi14, r7, r10, sh7, ema_diff)
        entry_today = entry_today.reindex(top)
        risk_on = (entry_today >= ENTRY_OK_THRESHOLD)

        breadth = float(risk_on.mean()*100.0) if len(risk_on) else 0.0
        exposure = exposure_from_breadth(breadth)

        score = compute_score_parts(d, df_day)
        confidence = CONF_BLEND_ENTRY*entry_today.clip(0,100) + (1.0-CONF_BLEND_ENTRY)*score.clip(0,100)

        w = pd.Series(0.0, index=C.columns)
        elig_conf = confidence[risk_on].dropna()
        if len(elig_conf) > 0:
            raw = (elig_conf/100.0) ** CONF_EXPONENT
            raw = raw / raw.sum() if raw.sum() > 0 else raw
            w_elig = (raw * 100.0).clip(0, MAX_WEIGHT_PCT)
            tot = w_elig.sum()
            if tot > 0: w_elig = w_elig * (100.0/tot)
            w.loc[w_elig.index] = w_elig.values

        w = (w * exposure) / 100.0
        r = ret1.loc[d].fillna(0.0)
        port_ret = float(np.nansum(w * r))
        equity.iloc[i] = equity.iloc[i-1] * (1.0 + port_ret)

    equity = equity.dropna()

    try:
        btc = get_ohlcv("BTC", start=str(dates.min().date()))["Close"].reindex(dates).ffill()
        btc_eq = btc / btc.iloc[0]
    except Exception:
        btc_eq = None

    daily = equity.pct_change().dropna()
    def drawdown_curve(x): return x/x.cummax() - 1.0
    total_ret = equity.iloc[-1] - 1.0
    cagr = (equity.iloc[-1]) ** (365.0/len(equity)) - 1.0 if len(equity)>1 else 0.0
    sh   = sharpe(daily)
    neg  = daily[daily<0]
    so   = (daily.mean()/neg.std(ddof=0))*math.sqrt(365) if len(neg)>0 and neg.std(ddof=0)>0 else 0.0
    mdd  = drawdown_curve(equity).min()

    stats = {"TotalReturn": float(total_ret), "CAGR": float(cagr), "Sharpe": float(sh), "Sortino": float(so), "MaxDD": float(mdd)}
    return equity, btc_eq, stats

# ============================= PNG: render table (COLORED) =============================
def _posneg_shade(val, scale=1.0):
    """Return facecolor for signed values."""
    if pd.isna(val) or val == 0: return None
    v = float(val)
    cap = 30.0  # cap magnitude for intensity
    t = min(abs(v), cap) / cap
    if v > 0:
        # blend toward green
        return C_POS_BASE
    else:
        return C_NEG_BASE

def _set_cell_face(cell, color, edge=None):
    if color:
        cell.set_facecolor(color)
        cell.set_edgecolor(edge if edge else "#2a2a2a")

def save_table_png(df, meta, path, max_rows=15):
    show = df.head(max_rows).copy()
    cols = ["Rank","Token","Signal","Score","Entry %","Risk Gauge","3d Return","7d Return","14d Return",
            "RSI Short","RSI Med","Vol. Trend","Momentum","Sharpe 7d","EMA Diff","Close","Confidence %","Suggested Wt %"]
    cols = [c for c in cols if c in show.columns]
    show = show[cols]

    # Format strings
    def fmt(series, spec): return series.map(lambda x: spec.format(x) if pd.notna(x) else "")
    mapf = {
        "Confidence %":"{:.1f}","Score":"{:.1f}","Entry %":"{:.1f}",
        "3d Return":"{:+.2f}","7d Return":"{:+.2f}","14d Return":"{:+.2f}",
        "RSI Short":"{:.2f}","RSI Med":"{:.2f}",
        "Sharpe 7d":"{:.2f}","Momentum":"{:+.2f}","Vol. Trend":"{:+.2f}",
        "EMA Diff":"{:+.2f}","Suggested Wt %":"{:.1f}","Close":"{:.6f}"
    }
    for c, spec in mapf.items():
        if c in show.columns: show[c] = fmt(show[c], spec)

    fig, ax = plt.subplots(figsize=(13.5, 0.60*len(show)+2.0))
    ax.axis("off")
    title = (
        f"Majors Screener â€” Top {len(show)} by 14d $Volume â€” {meta['today'].date()}  |  "
        f"Breadth(Entryâ‰¥{ENTRY_OK_THRESHOLD:.0f}%)={meta['breadth']:.1f}%  |  Exposure Scale={meta['exposure']*100:.0f}%  |  Total Alloc={meta['alloc_sum']:.1f}%"
    )
    ax.set_title(title, fontsize=11.5, loc="left", pad=12, color=C_TEXT)

    the_table = ax.table(cellText=show.values, colLabels=show.columns, loc="center", cellLoc="center")
    the_table.auto_set_font_size(False)
    the_table.set_fontsize(9)
    the_table.scale(1.0, 1.25)

    # Base styling
    for (r, c), cell in the_table.get_celld().items():
        if r == 0:
            _set_cell_face(cell, C_HDR)
            cell.set_text_props(color=C_TEXT_HDR, weight="bold")
        else:
            row_bg = C_BG_EVEN if r % 2 == 0 else C_BG_ODD
            _set_cell_face(cell, row_bg)
            cell.set_text_props(color=C_TEXT)

    # Column indices helper
    col_index = {name:i for i,name in enumerate(show.columns, start=0)}

    # SIGNAL colors
    if "Signal" in col_index:
        cidx = col_index["Signal"]
        for r in range(1, len(show)+1):
            cell = the_table[r, cidx]
            text = show.iloc[r-1]["Signal"]
            if text == "BUY": _set_cell_face(cell, C_BUY)
            elif text == "HOLD": _set_cell_face(cell, C_HOLD)
            elif text == "SELL": _set_cell_face(cell, C_SELL)
            else: _set_cell_face(cell, C_NOTRADE)
            cell.set_text_props(color="black", weight="bold")

    # RISK GAUGE colors
    if "Risk Gauge" in col_index:
        cidx = col_index["Risk Gauge"]
        for r in range(1, len(show)+1):
            cell = the_table[r, cidx]
            text = show.iloc[r-1]["Risk Gauge"]
            if text == "RISK_ON": _set_cell_face(cell, C_RISK_ON)
            else: _set_cell_face(cell, C_RISK_OFF)
            cell.set_text_props(color="white", weight="bold")

    # Signed numeric shades
    signed_cols = [c for c in ["3d Return","7d Return","14d Return","Vol. Trend","Momentum","Sharpe 7d","EMA Diff"] if c in col_index]
    for sc in signed_cols:
        cidx = col_index[sc]
        for r in range(1, len(show)+1):
            raw_val = df.loc[df["Rank"]==int(show.iloc[r-1]["Rank"]), sc].values[0]
            col = _posneg_shade(raw_val)
            if col: _set_cell_face(the_table[r, cidx], col, edge=C_POS_EDGE if raw_val>0 else C_NEG_EDGE)

    # RSI thresholds
    if "RSI Short" in col_index:
        cidx = col_index["RSI Short"]
        for r in range(1, len(show)+1):
            v = df.loc[df["Rank"]==int(show.iloc[r-1]["Rank"]), "RSI Short"].values[0]
            col = C_POS_BASE if v >= 55 else C_NEG_BASE
            _set_cell_face(the_table[r, cidx], col)
    if "RSI Med" in col_index:
        cidx = col_index["RSI Med"]
        for r in range(1, len(show)+1):
            v = df.loc[df["Rank"]==int(show.iloc[r-1]["Rank"]), "RSI Med"].values[0]
            col = C_POS_BASE if v >= 50 else C_NEG_BASE
            _set_cell_face(the_table[r, cidx], col)

    # Bars: Confidence % (green) and Suggested Wt % (gray)
    def add_bar(r, cidx, pct, color):
        cell = the_table[r, cidx]
        x, y = cell.get_x(), cell.get_y()
        w, h = cell.get_width(), cell.get_height()
        pw = max(0.0, min(1.0, pct/100.0)) * (w - 0.01)
        rect = Rectangle((x+0.005, y+0.005), pw, h-0.01, transform=ax.transData, linewidth=0, facecolor=color, alpha=0.85, zorder=0.5)
        ax.add_patch(rect)

    if "Confidence %" in col_index:
        cidx = col_index["Confidence %"]
        for r in range(1, len(show)+1):
            pct = float(df.loc[df["Rank"]==int(show.iloc[r-1]["Rank"]), "Confidence %"].values[0])
            add_bar(r, cidx, pct, C_BAR_GREEN)

    if "Suggested Wt %" in col_index:
        cidx = col_index["Suggested Wt %"]
        for r in range(1, len(show)+1):
            pct = float(df.loc[df["Rank"]==int(show.iloc[r-1]["Rank"]), "Suggested Wt %"].values[0])
            add_bar(r, cidx, pct, C_BAR_GRAY)

    plt.tight_layout()
    plt.savefig(path, dpi=150, bbox_inches="tight")
    plt.close()
    log(f"Saved table PNG -> {os.path.abspath(path)}")

# ============================= HTML (simple & matching colors) =============================
def style_table_simple(df, meta):
    # Build colored HTML similar to PNG
    def td(txt, style): return f"<td style='{style}'>{txt}</td>"
    def th(txt): return f"<th style='background:{C_HDR};color:{C_TEXT_HDR};padding:6px 8px;border:1px solid #333;text-transform:uppercase;letter-spacing:.02em'>{txt}</th>"

    cols = list(df.columns)
    header = "<tr>" + "".join(th(c) for c in cols) + "</tr>"

    rows_html = []
    for i, row in df.iterrows():
        r = int(row["Rank"])
        base = C_BG_EVEN if (r % 2)==0 else C_BG_ODD
        tstyle = f"padding:6px 8px;border:1px solid #333;background:{base};color:{C_TEXT};text-align:center"

        cells = []
        for c in cols:
            val = row[c]
            s = tstyle
            if c == "Signal":
                bg = {"BUY":C_BUY,"HOLD":C_HOLD,"SELL":C_SELL}.get(str(val),"#555555")
                s = s.replace(base, bg) + ";font-weight:700;color:black"
            elif c == "Risk Gauge":
                bg = C_RISK_ON if str(val)=="RISK_ON" else C_RISK_OFF
                s = s.replace(base, bg) + ";font-weight:700;color:white"
            elif c in ["3d Return","7d Return","14d Return","Vol. Trend","Momentum","Sharpe 7d","EMA Diff","RSI Short","RSI Med"]:
                try:
                    fv = float(val)
                except:
                    fv = None
                if fv is not None:
                    if c in ["RSI Short","RSI Med"]:
                        thrs = 55 if c=="RSI Short" else 50
                        bg = C_POS_BASE if fv>=thrs else C_NEG_BASE
                    else:
                        bg = C_POS_BASE if fv>0 else C_NEG_BASE if fv<0 else base
                    s = s.replace(base, bg)
            # bars in HTML
            if c in ["Confidence %","Suggested Wt %"]:
                try:
                    pct = float(val)
                except:
                    pct = 0.0
                bar_color = C_BAR_GREEN if c=="Confidence %" else C_BAR_GRAY
                bar = f"""
                  <div style="position:relative;height:14px;background:transparent;border-radius:2px">
                    <div style="position:absolute;left:0;top:0;height:100%;width:{max(0,min(100,pct))}%;background:{bar_color};opacity:.85"></div>
                    <div style="position:absolute;left:0;top:0;width:100%;height:100%;line-height:14px;color:#fff">{val:.1f}</div>
                  </div>
                """
                cells.append(td(bar, s))
            else:
                cells.append(td(f"{val}", s))
        rows_html.append("<tr>" + "".join(cells) + "</tr>")

    caption = (
        f"<h3 style='color:{C_TEXT};font-weight:600'>Majors Screener â€” {meta['today'].date()} | "
        f"Breadthâ‰¥{ENTRY_OK_THRESHOLD:.0f}%: {meta['breadth']:.1f}% | "
        f"Exposure: {meta['exposure']*100:.0f}% | Alloc: {meta['alloc_sum']:.1f}%</h3>"
    )
    table = "<table style='border-collapse:collapse;width:100%'>" + header + "".join(rows_html) + "</table>"
    return caption + table

def save_html_simple(html, path):
    with open(path, "w", encoding="utf-8") as f:
        f.write(
            "<html><head><meta charset='utf-8'><style>"
            f"body{{background:#111;color:{C_TEXT};font-family:system-ui,Segoe UI,Roboto,Arial}}"
            "a, a:visited{color:#8ab4f8}"
            "</style></head><body>"
            + html +
            "</body></html>"
        )

# ============================= MAIN =============================
def main():
    log(f"Universe: {MAJORS}")
    log("Downloading daily data from CryptoCompare â€¦")
    frames = load_universe(MAJORS, start=LOOKBACK_START)
    C,H,L,V,VT = align_panel(frames)
    coverage = C.notna().mean().mean()
    log(f"Average price coverage: {coverage*100:.1f}%")

    # Drop today's partial candle if running before UTC close
    if C.index[-1].date() == date.today():
        C = C.iloc[:-1]; H = H.iloc[:-1]; L = L.iloc[:-1]; V = V.iloc[:-1]; VT = VT.iloc[:-1]

    # Table
    table, meta = build_table_today(C,H,L,V,VT)

    # Save HTML/CSV and open in Chrome
    if WRITE_HTML_CSV:
        table.to_csv(OUT_CSV, index=False)
        html = style_table_simple(table, meta)
        save_html_simple(html, OUT_HTML)
        log(f"Saved CSV -> {os.path.abspath(OUT_CSV)}")
        log(f"Saved HTML -> {os.path.abspath(OUT_HTML)}")
        if OPEN_IN_CHROME:
            open_in_chrome(OUT_HTML)

    # Backtest from 2025
    eq, btc_eq, stats = backtest(C,H,L,V,VT, start=BACKTEST_START, end=BACKTEST_END)
    log("Rendering backtest chart â€¦")
    plt.figure(figsize=(11,5.8))
    plt.plot(eq.index, eq.values, label="RSPS (hybrid majors)")
    if btc_eq is not None:
        plt.plot(eq.index, btc_eq.reindex(eq.index).values, label="BTC HODL")
    plt.yscale("log")
    plt.title(f"Majors RSPS vs BTC (log) â€” {BACKTEST_START} â†’ {eq.index[-1].date()}")
    plt.xlabel("Date"); plt.ylabel("Equity (log)")
    box = (
        f"Total: {stats['TotalReturn']*100:.1f}%\n"
        f"CAGR:  {stats['CAGR']*100:.1f}%\n"
        f"Sharpe:{stats['Sharpe']:.2f}\n"
        f"Sort.: {stats['Sortino']:.2f}\n"
        f"MaxDD: {stats['MaxDD']*100:.1f}%"
    )
    plt.legend()
    plt.gcf().text(0.78, 0.50, box, fontsize=10,
                   bbox=dict(boxstyle="round", facecolor="#111", edgecolor="#444"),
                   color="#ddd")
    plt.tight_layout()
    plt.savefig(OUT_BACKTEST_PNG, dpi=150)
    plt.close()
    log(f"Saved backtest PNG -> {os.path.abspath(OUT_BACKTEST_PNG)}")

    # Table PNG
    save_table_png(table, meta, OUT_TABLE_PNG, max_rows=15)

    # Console summary
    print("\n===== Majors Screener â€”", meta['today'].date(), "=====")
    print(f"Breadth (Entry%â‰¥{ENTRY_OK_THRESHOLD:.0f}%): {meta['breadth']:.1f}%  |  Exposure: {meta['exposure']*100:.0f}%  |  Alloc: {meta['alloc_sum']:.1f}%")
    print(table.to_string(index=False))
    print("\nSaved files:")
    print("  â€¢", os.path.abspath(OUT_BACKTEST_PNG))
    print("  â€¢", os.path.abspath(OUT_TABLE_PNG))
    if WRITE_HTML_CSV:
        print("  â€¢", os.path.abspath(OUT_CSV))
        print("  â€¢", os.path.abspath(OUT_HTML))

if __name__ == "__main__":
    main()





