# ============================= Meme-Coin Screener â€” CC ONLY (once/day, low calls) =============================
# File name:  ALT LEAGUE   (no extension; run with:  python "ALT LEAGUE")
# Data:       CryptoCompare ONLY (CCCAGG aggregate). One API call per coin (uses allData=true).
# Cache:      Optional local .cc_cache/ parquet.
# Outputs:    meme_screener_daily.html, meme_screener_daily.csv, meme_screener_table.png, meme_rsps_backtest.png
# Posting:    Posts table+backtest PNGs to Discord via hard-coded webhook.

import os, time, math
from datetime import datetime, date
import numpy as np
import pandas as pd
import requests

os.environ.setdefault("MPLBACKEND", "Agg")
import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle

# ------------------------------ HARD-CODED SECRETS (per request) ------------------------------
CRYPTOCOMPARE_API_KEY = "c7932923a3058aa813332cdb3829b67e4a47998c6bdcf7adfac40d6a0f86c417"
DISCORD_WEBHOOK = "https://canary.discord.com/api/webhooks/1429701285975949322/fS0y9EkVQtnP15CJkAQEHEdpgL5Hlk43-Ct4D9uyZjjJT2jbk9nPkETT5cbbGGDyPVqD"

# ------------------------------ CONFIG ------------------------------
MEME_TICKERS = [
    "DOGE","SHIB","PEPE","FLOKI","BONK","WIF","BOME","POPCAT","PONKE","MEW","MYRO","MOG",
    "WOJAK","MAGA","TURBO","AIDOGE","ELON","PORK","LADYS","KISHU","AKITA","HOGE","PEPE2",
    "BNB","APE","ZEC","DASH","ZEN","ALU"
]
LOOKBACK_START   = "2021-01-01"
TOP_K_DOLLAR_VOL = 25
ROLL_VOL_DAYS    = 14

ENTRY_OK_THRESHOLD = 60.0
BREADTH_MIN        = 20.0
BREADTH_FULL       = 50.0
CONF_BLEND_ENTRY   = 0.50
CONF_EXPONENT      = 1.25
MAX_WEIGHT_PCT     = 25.0
MIN_SHOW_WEIGHT    = 0.25

OUT_HTML         = "meme_screener_daily.html"
OUT_CSV          = "meme_screener_daily.csv"
OUT_TABLE_PNG    = "meme_screener_table.png"
OUT_BACKTEST_PNG = "meme_rsps_backtest.png"
OPEN_AFTER_SAVE  = False
RUN_BACKTEST     = True

BACKTEST_START = "2021-01-01"
BACKTEST_END   = None

SESSION   = requests.Session()
TIMEOUT_S = 30

CACHE_DIR = ".cc_cache"
os.makedirs(CACHE_DIR, exist_ok=True)

np.set_printoptions(suppress=True)
pd.set_option("display.width", 180)
pd.set_option("display.max_columns", 50)

def log(msg): print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] {msg}")

# ------------------------------ Data fetch (CryptoCompare) ------------------------------
def cc_headers():
    return {"authorization": f"Apikey {CRYPTOCOMPARE_API_KEY}"}

def _cache_path(sym, tsym="USD"):
    return os.path.join(CACHE_DIR, f"{sym}_{tsym}_cccagg.parquet")

def cc_histoday_all(sym, tsym="USD"):
    url = "https://min-api.cryptocompare.com/data/v2/histoday"
    params = {"fsym": sym, "tsym": tsym, "allData": "true"}
    r = SESSION.get(url, params=params, headers=cc_headers(), timeout=TIMEOUT_S)
    if r.status_code == 429:
        raise RuntimeError("CC 429: rate limit")
    r.raise_for_status()
    j = r.json()
    if j.get("Response") != "Success":
        raise RuntimeError(j.get("Message", "CC error"))
    df = pd.DataFrame(j["Data"]["Data"])
    if df.empty:
        return pd.DataFrame()
    df["Date"] = pd.to_datetime(df["time"], unit="s", utc=True).dt.tz_convert("UTC").dt.tz_localize(None)
    df = df.set_index("Date").rename(columns={
        "open":"Open","high":"High","low":"Low","close":"Close",
        "volumefrom":"VolumeFrom","volumeto":"VolumeTo"
    })
    return df

def get_ohlcv_cc_cached(sym, start="2021-01-01"):
    path = _cache_path(sym, "USD")
    if os.path.exists(path):
        try:
            df = pd.read_parquet(path)
            try:
                fresh = cc_histoday_all(sym, "USD").last("20D")
                df = pd.concat([df, fresh]).sort_index()
                df = df[~df.index.duplicated(keep="last")]
                df.to_parquet(path)
            except Exception:
                pass
            return df[df.index >= pd.to_datetime(start)]
        except Exception:
            pass
    df = cc_histoday_all(sym, "USD")
    if not df.empty:
        try: df.to_parquet(path)
        except Exception: pass
    return df[df.index >= pd.to_datetime(start)]

def get_ohlcv(symbol, start="2021-01-01"):
    return get_ohlcv_cc_cached(symbol, start=start)

# ------------------------------ Indicators & helpers ------------------------------
def ema(s, n): return s.ewm(span=n, adjust=False).mean()

def rsi(series, length=14):
    s = series.astype(float); d = s.diff()
    up = np.where(d > 0, d, 0.0); dn = np.where(d < 0, -d, 0.0)
    up_ewm = pd.Series(up, index=s.index).ewm(alpha=1/length, adjust=False).mean()
    dn_ewm = pd.Series(dn, index=s.index).ewm(alpha=1/length, adjust=False).mean()
    rs = up_ewm / (dn_ewm.replace(0, np.nan))
    return (100 - (100 / (1 + rs))).fillna(0)

def sharpe(r, ppy=365):
    r = r.dropna()
    if r.empty: return 0.0
    sd = r.std(ddof=0)
    return 0.0 if sd==0 or np.isnan(sd) else (r.mean()/sd)*math.sqrt(ppy)

def exposure_from_breadth(breadth_pct, bmin=BREADTH_MIN, bfull=BREADTH_FULL):
    if bfull <= bmin: return 0.0
    x = (breadth_pct - bmin) / (bfull - bmin)
    return float(np.clip(x, 0.0, 1.0))

# ------------------------------ Panel build ------------------------------
def load_universe(symbols, start):
    frames, failed = {}, []
    for sym in symbols:
        try:
            df = get_ohlcv(sym, start=start)
            if df is None or df.empty: failed.append(sym)
            else: frames[sym] = df
        except Exception as e:
            failed.append(sym); log(f"FAIL {sym}: {e}")
        time.sleep(0.05)
    if failed: log(f"Skipped (no market / error): {failed}")
    if not frames: raise RuntimeError("No symbols had valid markets on CryptoCompare.")
    return frames

def align_panel(frames):
    all_idx = None
    for df in frames.values():
        all_idx = df.index if all_idx is None else all_idx.union(df.index)
    all_idx = all_idx.sort_values(); cols = list(frames.keys())
    C = pd.DataFrame(index=all_idx, columns=cols, dtype=float)
    H = pd.DataFrame(index=all_idx, columns=cols, dtype=float)
    L = pd.DataFrame(index=all_idx, columns=cols, dtype=float)
    V = pd.DataFrame(index=all_idx, columns=cols, dtype=float)
    VT= pd.DataFrame(index=all_idx, columns=cols, dtype=float)
    for sym, df in frames.items():
        C.loc[df.index, sym]  = df["Close"].astype(float)
        H.loc[df.index, sym]  = df["High"].astype(float)
        L.loc[df.index, sym]  = df["Low"].astype(float)
        V.loc[df.index, sym]  = df["VolumeFrom"].astype(float)
        VT.loc[df.index, sym] = df["VolumeTo"].astype(float)
    return C,H,L,V,VT

# ------------------------------ Screener core ------------------------------
def entry_checks_for_day(idx, C,H,L,V, ema20,ema50, rsi3,rsi14, r7, r10, sh7, ema_diff):
    checks = {
        ">EMA20":   (C.loc[idx] > ema20.loc[idx]),
        "RSI3>55":  (rsi3.loc[idx] > 55),
        "RSI14>50": (rsi14.loc[idx] > 50),
        "ROC10>0":  (r10.loc[idx] > 0),
        "7d>0":     (r7.loc[idx]  > 0),
        "Sharpe+":  (sh7.loc[idx] > 0),
        "EMA+":     (ema_diff.loc[idx] > 0),
    }
    df = pd.DataFrame(checks)
    entry_pct = df.mean(axis=1) * 100.0
    return df, entry_pct

def compute_score_parts(idx, df_day):
    def pct_rank(s):
        s = pd.Series(s).replace([np.inf,-np.inf], np.nan)
        return s.rank(pct=True, method="average")
    w = {"r7":0.18,"r14":0.18,"mom":0.18,"rsi_med":0.14,"sh7":0.14,"ema":0.12,"voltr":0.06}
    parts = {
        "r7": pct_rank(df_day["7d Return"]),
        "r14": pct_rank(df_day["14d Return"]),
        "mom": pct_rank(df_day["Momentum"]),
        "rsi_med": pct_rank(df_day["RSI Med"]),
        "sh7": pct_rank(df_day["Sharpe 7d"]),
        "ema": pct_rank(df_day["EMA Diff"]),
        "voltr": pct_rank(df_day["Vol. Trend"])
    }
    score = sum(parts[k]*w[k] for k in w) * 100.0
    return score

def build_table_today(C,H,L,V,VT):
    ret1 = C.pct_change()
    r3  = C.pct_change(3);  r7  = C.pct_change(7);  r14 = C.pct_change(14)
    r10 = C.pct_change(10)
    rsi3  = C.apply(lambda s: rsi(s, 3));  rsi14 = C.apply(lambda s: rsi(s,14))
    ema20 = C.apply(lambda s: ema(s,20));  ema50 = C.apply(lambda s: ema(s,50))
    v7 = V.rolling(7).mean(); v28 = V.rolling(28).mean(); vol_trend = (v7/v28 - 1.0)
    sh7 = ret1.rolling(7).apply(lambda x: sharpe(pd.Series(x)), raw=False)
    ema_diff = (C/ema50 - 1.0) * 100.0
    dv14 = VT.rolling(ROLL_VOL_DAYS).sum()

    today = C.index[-1]; yday = C.index[-2] if len(C.index) >= 2 else today

    dv_today = dv14.loc[today].dropna().sort_values(ascending=False)
    top_syms = list(dv_today.index[:TOP_K_DOLLAR_VOL])
    if not top_syms: raise RuntimeError("No symbols have dollar-volume; check API responses.")

    _, entry_pct_today = entry_checks_for_day(today, C,H,L,V, ema20,ema50, rsi3,rsi14, r7, r10, sh7, ema_diff)
    _, entry_pct_prev  = entry_checks_for_day(yday,  C,H,L,V, ema20,ema50, rsi3,rsi14, r7, r10, sh7, ema_diff)

    entry_pct_today = entry_pct_today.reindex(top_syms)
    entry_pct_prev  = entry_pct_prev.reindex(top_syms)
    coin_risk = np.where(entry_pct_today >= ENTRY_OK_THRESHOLD, "RISK_ON", "RISK_OFF")

    df = pd.DataFrame(index=top_syms)
    df["Token"]      = [sym + "USDT" for sym in top_syms]
    df["3d Return"]  = r3.loc[today, top_syms].values * 100
    df["7d Return"]  = r7.loc[today, top_syms].values * 100
    df["14d Return"] = r14.loc[today, top_syms].values * 100
    df["RSI Short"]  = rsi3.loc[today, top_syms].values
    df["RSI Med"]    = rsi14.loc[today, top_syms].values
    df["Vol. Trend"] = vol_trend.loc[today, top_syms].values
    df["Momentum"]   = r10.loc[today, top_syms].values
    df["Sharpe 7d"]  = sh7.loc[today, top_syms].values
    df["EMA Diff"]   = ema_diff.loc[today, top_syms].values
    df["Close"]      = C.loc[today, top_syms].values
    df["Entry %"]    = entry_pct_today.values
    df["Risk Gauge"] = coin_risk

    df["Score"] = compute_score_parts(today, df).values
    conf = CONF_BLEND_ENTRY*df["Entry %"].clip(0,100) + (1.0-CONF_BLEND_ENTRY)*df["Score"].clip(0,100)
    df["Confidence %"] = conf.values

    prev_pass = (entry_pct_prev >= ENTRY_OK_THRESHOLD).fillna(False)
    curr_pass = (entry_pct_today >= ENTRY_OK_THRESHOLD).fillna(False)
    signal = np.where(curr_pass & ~prev_pass, "BUY",
                      np.where(curr_pass & prev_pass, "HOLD",
                               np.where(~curr_pass & prev_pass, "SELL", "NO TRADE")))
    df["Signal"] = signal

    breadth_pct = float((df["Entry %"] >= ENTRY_OK_THRESHOLD).mean()*100.0)
    exposure = exposure_from_breadth(breadth_pct)

    eligible = (df["Risk Gauge"] == "RISK_ON")
    raw = pd.Series(0.0, index=df.index)
    if eligible.any():
        raw_elig = (df.loc[eligible, "Confidence %"] / 100.0) ** CONF_EXPONENT
        raw_elig = raw_elig / raw_elig.sum() if raw_elig.sum() > 0 else raw_elig
        wts = (raw_elig * 100.0).clip(0, MAX_WEIGHT_PCT)
        total = wts.sum()
        if total > 0: wts = wts * (100.0 / total)
        raw.loc[wts.index] = wts.values
    final_w = (raw * (exposure * 100.0)).where(lambda s: s >= MIN_SHOW_WEIGHT, 0.0)
    df["Suggested Wt %"] = final_w.values

    df = df.sort_values(by=["Confidence %","Score","Entry %"], ascending=False)
    df.insert(0, "Rank", range(1, len(df)+1))

    pct_cols = ["3d Return","7d Return","14d Return","EMA Diff","Entry %","Score","Confidence %","Suggested Wt %"]
    for c in pct_cols:
        if c in df.columns: df[c] = df[c].round(2)
    for c in ["RSI Short","RSI Med","Sharpe 7d","Momentum","Vol. Trend","Close"]:
        if c in df.columns: df[c] = df[c].round(2)

    meta = {"today": today, "breadth": breadth_pct, "exposure": exposure, "alloc_sum": float(df["Suggested Wt %"].sum())}
    df = df[["Rank","Token","Signal","Score","Entry %","Risk Gauge","3d Return","7d Return","14d Return",
             "RSI Short","RSI Med","Vol. Trend","Momentum","Sharpe 7d","EMA Diff","Close","Confidence %","Suggested Wt %"]]
    return df, meta

# ------------------------------ Styled HTML table ------------------------------
def style_table(df, meta):
    caption = (
        f"Meme Screener â€” Top {len(df)} by 14d $Volume â€” {meta['today'].date()}  |  "
        f"Breadth(Entryâ‰¥{ENTRY_OK_THRESHOLD:.0f}%)={meta['breadth']:.1f}%  |  "
        f"Exposure Scale={meta['exposure']*100:.0f}%  |  Total Alloc={meta['alloc_sum']:.1f}%"
    )
    def bar_0_100(s, color="#0a0"):
        v = s.astype(float)/100.0
        return [f"background:linear-gradient(90deg,{color} {int(100*x)}%,#222 {int(100*x)}%); color:#ddd;" for x in v]
    def green_if_pos_red_if_neg(s):
        out=[]
        for x in s.astype(float):
            if np.isnan(x): out.append("")
            elif x > 0: out.append("background-color:#0a260a; color:#00d000;")
            else:       out.append("background-color:#2a0d0d; color:#ff6b6b;")
        return out
    def green_if_over(s, thr):
        out=[]
        for x in s.astype(float):
            if np.isnan(x): out.append("")
            elif x > thr:  out.append("background-color:#0a260a; color:#00d000;")
            else:          out.append("background-color:#2a0d0d; color:#ff6b6b;")
        return out
    def risk_gauge_boxes(s):
        out=[]
        for v in s.astype(str):
            if v == "RISK_ON": out.append("background-color:#0a0; color:#fff; font-weight:700; text-align:center; border:1px solid #0b6f0b;")
            elif v == "RISK_OFF": out.append("background-color:#b00000; color:#fff; font-weight:700; text-align:center; border:1px solid #7a0000;")
            else: out.append("text-align:center;")
        return out
    def signal_badges(s):
        out=[]
        for v in s.astype(str):
            if v == "BUY": out.append("background-color:#0a0; color:#fff; font-weight:700; text-align:center; border:1px solid #0b6f0b;")
            elif v == "SELL": out.append("background-color:#b00000; color:#fff; font-weight:700; text-align:center; border:1px solid #7a0000;")
            elif v == "HOLD": out.append("background-color:#f59e0b; color:#1b1200; font-weight:700; text-align:center; border:1px solid #a86b06;")
            else: out.append("background-color:#3a3a3a; color:#eee; text-align:center; border:1px solid #2a2a2a;")
        return out

    return (
        df.style.set_caption(caption).hide(axis="index")
        .apply(lambda s: bar_0_100(s, "#0a0"), subset=["Entry %","Confidence %"])
        .apply(lambda s: bar_0_100(s, "#0aa"), subset=["Suggested Wt %"])
        .apply(green_if_pos_red_if_neg, subset=["3d Return","7d Return","14d Return","Vol. Trend","Momentum","Sharpe 7d","EMA Diff"])
        .apply(lambda s: green_if_over(s, 55), subset=["RSI Short"])
        .apply(lambda s: green_if_over(s, 50), subset=["RSI Med"])
        .apply(signal_badges, subset=["Signal"])
        .apply(risk_gauge_boxes, subset=["Risk Gauge"])
        .background_gradient(axis=None, cmap="Greens", subset=["Score"])
        .set_table_styles([
            {"selector":"table","props":[
                ("background-color","#181818"),("color","#ddd"),
                ("border-collapse","separate"),("border-spacing","0"),
                ("font-family","-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,'Helvetica Neue',Arial,'Noto Sans','Liberation Sans',sans-serif"),
                ("font-size","13px"),("line-height","1.35"),("font-variant-numeric","tabular-nums lining-nums"),
                ("border","1px solid #2a2aa"),("border-radius","10px"),("overflow","hidden")
            ]},
            {"selector":"th","props":[
                ("background-color","#000"),("color","#fff"),
                ("text-transform","uppercase"),("letter-spacing","0.02em"),
                ("font-weight","700"),("padding","8px 10px"),("border-bottom","1px solid #333")
            ]},
            {"selector":"caption","props":[
                ("caption-side","top"),("background-color","#000"),("color","#fff"),
                ("font-weight","600"),("font-size","14px"),("padding","10px 12px"),("text-align","left")
            ]},
            {"selector":"td","props":[
                ("padding","7px 10px"),("border-bottom","1px solid #242424"),
                ("border-right","1px solid #202020"),("vertical-align","middle")
            ]},
            {"selector":"td:last-child","props":[("border-right","none")]},
        ])
        .format({
            "Rank":"{:d}",
            "Score":"{:.2f}",
            "Entry %":"{:.1f}%",
            "Confidence %":"{:.1f}%",
            "Suggested Wt %":"{:.1f}%",
            "3d Return":"{:+.2f}%",
            "7d Return":"{:+.2f}%",
            "14d Return":"{:+.2f}%",
            "RSI Short":"{:.2f}",
            "RSI Med":"{:.2f}",
            "Vol. Trend":"{:+.2f}",
            "Momentum":"{:+.2f}",
            "Sharpe 7d":"{:.2f}",
            "EMA Diff":"{:+.2f}%",
            "Close":"{:.6f}"
        })
    )

# ------------------------------ PNG table (defined BEFORE main) ------------------------------
_C_HDR      = "#0b0b0b"; _C_BG_EVEN  = "#1b1b1b"; _C_BG_ODD   = "#202020"
_C_TEXT     = "#dddddd"; _C_TEXT_HDR = "#ffffff"
_C_BUY      = "#1fa971"; _C_HOLD="#dca408"; _C_SELL="#d14b41"; _C_NT="#555555"
_C_RON      = "#0f7d4f"; _C_ROFF="#943233"
_C_POS      = "#10361e"; _C_NEG="#3a1515"
_C_BAR_G    = "#2fb66f"; _C_BAR_GR="#8a8a8a"

def save_table_png(df, meta, path, max_rows=25):
    show = df.head(max_rows).copy()
    cols = ["Rank","Token","Signal","Score","Entry %","Risk Gauge","3d Return","7d Return","14d Return",
            "RSI Short","RSI Med","Vol. Trend","Momentum","Sharpe 7d","EMA Diff","Close","Confidence %","Suggested Wt %"]
    cols = [c for c in cols if c in show.columns]; show = show[cols]
    def fmt(series, spec): return series.map(lambda x: spec.format(x) if pd.notna(x) else "")
    fmts = {"Score":"{:.1f}","Entry %":"{:.1f}","3d Return":"{:+.2f}","7d Return":"{:+.2f}",
            "14d Return":"{:+.2f}","RSI Short":"{:.2f}","RSI Med":"{:.2f}","Vol. Trend":"{:+.2f}",
            "Momentum":"{:+.2f}","Sharpe 7d":"{:.2f}","EMA Diff":"{:+.2f}","Close":"{:.6f}",
            "Confidence %":"{:.1f}","Suggested Wt %":"{:.1f}"}
    for c, spec in fmts.items():
        if c in show.columns: show[c] = fmt(show[c], spec)

    fig, ax = plt.subplots(figsize=(13.5, 0.62*len(show)+2.0)); ax.axis("off")
    title = (f"Meme Screener â€” Top {len(show)} by 14d $Volume â€” {meta['today'].date()}  |  "
             f"Breadthâ‰¥{ENTRY_OK_THRESHOLD:.0f}%: {meta['breadth']:.1f}%  |  "
             f"Exposure: {meta['exposure']*100:.0f}%  |  Total Alloc: {meta['alloc_sum']:.1f}%")
    ax.set_title(title, fontsize=12, loc="left", pad=12, color=_C_TEXT)

    table = ax.table(cellText=show.values, colLabels=show.columns, loc="center", cellLoc="center")
    table.auto_set_font_size(False); table.set_fontsize(9); table.scale(1.0, 1.25)
    for (r,c), cell in table.get_celld().items():
        if r == 0:
            cell.set_facecolor(_C_HDR); cell.set_text_props(color=_C_TEXT_HDR, weight="bold")
        else:
            cell.set_facecolor(_C_BG_EVEN if r%2==0 else _C_BG_ODD); cell.set_text_props(color=_C_TEXT)

    col_index = {name:i for i,name in enumerate(show.columns)}
    if "Signal" in col_index:
        ci = col_index["Signal"]
        for r in range(1, len(show)+1):
            v = show.iloc[r-1]["Signal"]
            cell = table[r, ci]; cell.set_facecolor({"BUY":_C_BUY,"HOLD":_C_HOLD,"SELL":_C_SELL}.get(v,_C_NT))
            cell.set_text_props(color="black", weight="bold")
    if "Risk Gauge" in col_index:
        ci = col_index["Risk Gauge"]
        for r in range(1, len(show)+1):
            v = show.iloc[r-1]["Risk Gauge"]
            cell = table[r, ci]; cell.set_facecolor(_C_RON if v=="RISK_ON" else _C_ROFF); cell.set_text_props(color="white", weight="bold")

    for sc in [c for c in ["3d Return","7d Return","14d Return","Vol. Trend","Momentum","Sharpe 7d","EMA Diff"] if c in col_index]:
        ci = col_index[sc]
        for r in range(1, len(show)+1):
            try: val = float(show.iloc[r-1][sc])
            except: val = np.nan
            if not np.isnan(val): table[r, ci].set_facecolor(_C_POS if val>0 else _C_NEG)
    for name,thr in [("RSI Short",55),("RSI Med",50)]:
        if name in col_index:
            ci = col_index[name]
            for r in range(1, len(show)+1):
                try: val = float(show.iloc[r-1][name])
                except: val = np.nan
                if not np.isnan(val): table[r, ci].set_facecolor(_C_POS if val>=thr else _C_NEG)

    def add_bar(r, ci, pct, color):
        cell = table[r, ci]; x, y = cell.get_x(), cell.get_y(); w, h = cell.get_width(), cell.get_height()
        try: p = max(0.0, min(1.0, float(pct)/100.0))
        except: p = 0.0
        rect = Rectangle((x+0.005, y+0.005), p*(w-0.01), h-0.01, transform=ax.transData, linewidth=0, facecolor=color, alpha=0.85, zorder=0.5)
        ax.add_patch(rect)
    for name,color in [("Confidence %", _C_BAR_G), ("Suggested Wt %", _C_BAR_GR)]:
        if name in col_index:
            ci = col_index[name]
            for r in range(1, len(show)+1):
                add_bar(r, ci, show.iloc[r-1][name], color)

    plt.tight_layout(); plt.savefig(path, dpi=150, bbox_inches="tight"); plt.close()
    log(f"Saved table PNG -> {os.path.abspath(path)}")

# ------------------------------ Discord posting ------------------------------
def post_to_discord(file_path, webhook=DISCORD_WEBHOOK):
    try:
        if not webhook or not os.path.exists(file_path):
            return
        with open(file_path, "rb") as f:
            r = requests.post(webhook, files={"file": (os.path.basename(file_path), f, "image/png")}, timeout=30)
        log(f"Discord post {os.path.basename(file_path)} -> {r.status_code}")
    except Exception as e:
        log(f"Discord post failed for {file_path}: {e}")

# ------------------------------ Backtest ------------------------------
def backtest(C,H,L,V,VT, start=None, end=None):
    ret1 = C.pct_change()
    r7  = C.pct_change(7);  r14 = C.pct_change(14);  r10 = C.pct_change(10)
    rsi3  = C.apply(lambda s: rsi(s, 3));  rsi14 = C.apply(lambda s: rsi(s,14))
    ema20 = C.apply(lambda s: ema(s,20));  ema50 = C.apply(lambda s: ema(s,50))
    v7 = V.rolling(7).mean(); v28 = V.rolling(28).mean()
    sh7 = ret1.rolling(7).apply(lambda x: sharpe(pd.Series(x)), raw=False)
    ema_diff = (C/ema50 - 1.0) * 100.0
    dv14 = VT.rolling(ROLL_VOL_DAYS).sum()

    dates = C.index
    if start: dates = dates[dates >= pd.to_datetime(start)]
    if end:   dates = dates[dates <= pd.to_datetime(end)]
    if len(dates) < 30: raise RuntimeError("Backtest window too short.")

    equity = pd.Series(index=dates, dtype=float); equity.iloc[0] = 1.0
    for i in range(1, len(dates)):
        d = dates[i]
        dv_today = dv14.loc[d].dropna().sort_values(ascending=False)
        top = list(dv_today.index[:TOP_K_DOLLAR_VOL])

        df_day = pd.DataFrame(index=top)
        df_day["7d Return"]  = r7.loc[d, top].values * 100
        df_day["14d Return"] = r14.loc[d, top].values * 100
        df_day["Momentum"]   = r10.loc[d, top].values
        df_day["RSI Med"]    = rsi14.loc[d, top].values
        df_day["Sharpe 7d"]  = sh7.loc[d, top].values
        df_day["EMA Diff"]   = ema_diff.loc[d, top].values
        df_day["Vol. Trend"] = (v7.loc[d, top] / v28.loc[d, top] - 1.0).values

        _, entry_today = entry_checks_for_day(d, C,H,L,V, ema20,ema50, rsi3,rsi14, r7, r10, sh7, ema_diff)
        entry_today = entry_today.reindex(top)
        risk_on = (entry_today >= ENTRY_OK_THRESHOLD)

        breadth = float(risk_on.mean()*100.0) if len(risk_on) else 0.0
        exposure = exposure_from_breadth(breadth)

        score = compute_score_parts(d, df_day)
        confidence = CONF_BLEND_ENTRY*entry_today.clip(0,100) + (1.0-CONF_BLEND_ENTRY)*score.clip(0,100)

        w = pd.Series(0.0, index=C.columns)
        elig_conf = confidence[risk_on].dropna()
        if len(elig_conf) > 0:
            raw = (elig_conf/100.0) ** CONF_EXPONENT
            raw = raw / raw.sum() if raw.sum() > 0 else raw
            w_elig = (raw * 100.0).clip(0, MAX_WEIGHT_PCT)
            tot = w_elig.sum()
            if tot > 0: w_elig = w_elig * (100.0/tot)
            w.loc[w_elig.index] = w_elig.values

        w = (w * exposure) / 100.0
        r = ret1.loc[d].fillna(0.0)
        port_ret = float(np.nansum(w * r))
        equity.iloc[i] = equity.iloc[i-1] * (1.0 + port_ret)

    equity = equity.dropna()

    try:
        btc = get_ohlcv("BTC", start=str(dates.min().date()))["Close"].reindex(dates).ffill()
        btc_eq = btc / btc.iloc[0]
    except Exception:
        btc_eq = None

    daily = equity.pct_change().dropna()
    def drawdown_curve(x): return x/x.cummax() - 1.0
    total_ret = equity.iloc[-1] - 1.0
    cagr = (equity.iloc[-1]) ** (365.0/len(equity)) - 1.0 if len(equity)>1 else 0.0
    sh   = sharpe(daily)
    neg  = daily[daily<0]
    so   = (daily.mean()/neg.std(ddof=0))*math.sqrt(365) if len(neg)>0 and neg.std(ddof=0)>0 else 0.0
    mdd  = drawdown_curve(equity).min()
    stats = {"TotalReturn": float(total_ret), "CAGR": float(cagr), "Sharpe": float(sh), "Sortino": float(so), "MaxDD": float(mdd)}
    return equity, btc_eq, stats

# ------------------------------ MAIN ------------------------------
def main():
    log("Downloading daily data from CryptoCompare (CCCAGG, allData=true) â€¦")
    frames = load_universe(MEME_TICKERS, start=LOOKBACK_START)
    C,H,L,V,VT = align_panel(frames)

    # Drop today's partial candle if running before UTC close
    if C.index[-1].date() == date.today():
        C = C.iloc[:-1]; H = H.iloc[:-1]; L = L.iloc[:-1]; V = V.iloc[:-1]; VT = VT.iloc[:-1]

    coverage = C.notna().mean().mean()
    log(f"Average price coverage: {coverage*100:.1f}%")

    # Table
    table, meta = build_table_today(C,H,L,V,VT)
    table.to_csv(OUT_CSV, index=False)

    # HTML with fallback if jinja2/styler missing
    try:
        styled = style_table(table, meta)
        html_out = styled.to_html()
    except Exception as e:
        log(f"Styler unavailable ({e}); writing plain HTML table instead.")
        html_out = table.to_html(index=False)
    with open(OUT_HTML, "w", encoding="utf-8") as f:
        f.write(html_out)

    # PNG table
    save_table_png(table, meta, OUT_TABLE_PNG, max_rows=TOP_K_DOLLAR_VOL)

    # Backtest
    if RUN_BACKTEST:
        eq, btc_eq, stats = backtest(C,H,L,V,VT, start=BACKTEST_START, end=BACKTEST_END)
        plt.figure(figsize=(11,5.8))
        plt.plot(eq.index, eq.values, label="RSPS (hybrid)")
        if btc_eq is not None:
            plt.plot(eq.index, btc_eq.reindex(eq.index).values, label="BTC HODL")
        plt.yscale("log")
        plt.title(f"RSPS vs BTC (log scale) â€” {BACKTEST_START} â†’ {eq.index[-1].date()}")
        plt.xlabel("Date"); plt.ylabel("Equity (log)")
        box = (
            f"Total: {stats['TotalReturn']*100:.1f}%\n"
            f"CAGR:  {stats['CAGR']*100:.1f}%\n"
            f"Sharpe:{stats['Sharpe']:.2f}\n"
            f"Sort.: {stats['Sortino']:.2f}\n"
            f"MaxDD: {stats['MaxDD']*100:.1f}%"
        )
        plt.legend()
        plt.gcf().text(0.78, 0.50, box, fontsize=10,
                       bbox=dict(boxstyle="round", facecolor="#111", edgecolor="#444"),
                       color="#ddd")
        plt.tight_layout(); plt.savefig(OUT_BACKTEST_PNG, dpi=150); plt.close()
        log(f"Saved backtest PNG -> {os.path.abspath(OUT_BACKTEST_PNG)}")

    # Summary
    print("\n===== Meme Screener â€”", meta['today'].date(), "=====")
    print(f"Breadth (Entry%â‰¥{ENTRY_OK_THRESHOLD:.0f}%): {meta['breadth']:.1f}%  |  "
          f"Exposure: {meta['exposure']*100:.0f}%  |  Total Alloc: {meta['alloc_sum']:.1f}%")
    print(table.to_string(index=False))
    print("\nSaved:", OUT_CSV, "|", OUT_HTML, "|", OUT_TABLE_PNG, "|", (OUT_BACKTEST_PNG if RUN_BACKTEST else ""))

    # Discord posts
    post_to_discord(OUT_TABLE_PNG)
    if RUN_BACKTEST:
        post_to_discord(OUT_BACKTEST_PNG)

if __name__ == "__main__":
    main()









































