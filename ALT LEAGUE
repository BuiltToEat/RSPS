# ============================= Meme-Coin Screener — COINGECKO (key + retry) =============================
# File name:  ALT LEAGUE   (no extension; run with:  python "ALT LEAGUE")
# Data:       CoinGecko (market_chart days=max interval=daily)
# Notes:      Set env COINGECKO_API_KEY (free demo key ok). Built-in retry/backoff + polite delay.
# Outputs:    meme_screener_daily.html, meme_screener_daily.csv, meme_screener_table.png, meme_rsps_backtest.png

import os, time, math, random
from datetime import datetime, date
import numpy as np
import pandas as pd
import requests

os.environ.setdefault("MPLBACKEND", "Agg")
import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle

# -------------------------------- CONFIG --------------------------------
MEME_TICKERS = [
    "DOGE","SHIB","PEPE","FLOKI","BONK","WIF","BOME","POPCAT","PONKE","MEW","MYRO","MOG",
    "WOJAK","MAGA","TURBO","AIDOGE","ELON","PORK","LADYS","KISHU","AKITA","HOGE","PEPE2",
    "BNB","APE","ZEC","DASH","ZEN","ALU"
]

LOOKBACK_START   = "2021-01-01"
TOP_K_DOLLAR_VOL = 25
ROLL_VOL_DAYS    = 14

ENTRY_OK_THRESHOLD = 60.0
BREADTH_MIN        = 20.0
BREADTH_FULL       = 50.0
CONF_BLEND_ENTRY   = 0.50
CONF_EXPONENT      = 1.25
MAX_WEIGHT_PCT     = 25.0
MIN_SHOW_WEIGHT    = 0.25

OUT_HTML         = "meme_screener_daily.html"
OUT_CSV          = "meme_screener_daily.csv"
OUT_TABLE_PNG    = "meme_screener_table.png"
OUT_BACKTEST_PNG = "meme_rsps_backtest.png"
OPEN_AFTER_SAVE  = False
RUN_BACKTEST     = True

BACKTEST_START = "2021-01-01"
BACKTEST_END   = None

SESSION   = requests.Session()
TIMEOUT_S = 45

# polite pacing between coin requests (adjust via env if needed)
PER_REQUEST_DELAY_S = float(os.getenv("CG_DELAY_S", "1.6"))

# Optional local cache (helps locally; GitHub runners are ephemeral)
CACHE_DIR = ".cg_cache"
os.makedirs(CACHE_DIR, exist_ok=True)

np.set_printoptions(suppress=True)
pd.set_option("display.width", 180)
pd.set_option("display.max_columns", 50)

def log(msg): print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] {msg}")

# -------------------------------- CoinGecko helpers --------------------------------
CG_BASE = "https://api.coingecko.com/api/v3"

COINGECKO_IDS = {
    "BTC":"bitcoin","BNB":"binancecoin","APE":"apecoin","ZEC":"zcash","DASH":"dash","ZEN":"horizen","ALU":"altura",
    "DOGE":"dogecoin","SHIB":"shiba-inu","PEPE":"pepe","FLOKI":"floki","BONK":"bonk","WIF":"dogwifcoin","BOME":"book-of-meme",
    "POPCAT":"popcat","PONKE":"ponke","MEW":"cat-in-a-dogs-world","MYRO":"myro","MOG":"mog-coin","WOJAK":"wojak",
    "MAGA":"maga","TURBO":"turbo","AIDOGE":"arbdoge-ai","ELON":"dogelon-mars","PORK":"pepefork","LADYS":"milady-meme-coin",
    "KISHU":"kishu-inu","AKITA":"akita-inu","HOGE":"hoge-finance","PEPE2":"pepe-2-0",
}

def cg_headers():
    """
    CoinGecko now expects an API key. Support both demo and pro header names.
    Set env COINGECKO_API_KEY.
    """
    key = os.getenv("COINGECKO_API_KEY", "").strip()
    h = {"accept":"application/json"}
    if key:
        # send both; server will accept whichever applies to your plan
        h["x-cg-demo-api-key"] = key
        h["x-cg-pro-api-key"]  = key
    return h

def cg_request(url, params=None, max_retries=6):
    """
    Robust GET with exponential backoff + jitter on 429/5xx.
    Fail fast on 401/403 (auth issues).
    """
    backoff = 1.5
    for attempt in range(1, max_retries+1):
        r = SESSION.get(url, params=params, headers=cg_headers(), timeout=TIMEOUT_S)
        status = r.status_code
        if status == 200:
            return r
        if status in (401,403):
            # auth required/forbidden — tell the user clearly
            try_msg = r.json().get("error", "")
            raise RuntimeError(f"CoinGecko auth error ({status}). Set COINGECKO_API_KEY. {try_msg}")
        if status in (408,425,429,500,502,503,504,520,522):
            # backoff + jitter
            sleep_s = backoff * (1.0 + 0.2*random.random())
            log(f"CG {status} — retry {attempt}/{max_retries} in {sleep_s:.1f}s …")
            time.sleep(sleep_s)
            backoff *= 1.8
            continue
        # other statuses → raise
        r.raise_for_status()
    # if we exhausted retries, raise last response
    r.raise_for_status()

def cg_get_id(symbol):
    if symbol in COINGECKO_IDS:
        return COINGECKO_IDS[symbol]
    try:
        r = cg_request(f"{CG_BASE}/coins/list", params={"include_platform":"false"})
        items = r.json()
        sym_lower = symbol.lower()
        candidates = [x for x in items if x.get("symbol","").lower() == sym_lower]
        if not candidates: return None
        candidates = sorted(candidates, key=lambda x: (x["id"].startswith(sym_lower)==False, len(x["id"])))
        return candidates[0]["id"]
    except Exception:
        return None

def cg_market_chart_df(cg_id, vs="usd"):
    """
    /coins/{id}/market_chart?vs_currency=usd&days=max&interval=daily
    Returns daily Close + an approximate base volume derived from total_volumes.
    """
    url = f"{CG_BASE}/coins/{cg_id}/market_chart"
    r = cg_request(url, params={"vs_currency": vs, "days":"max", "interval":"daily"})
    j = r.json()
    prices = j.get("prices", [])
    vols   = j.get("total_volumes", [])
    if not prices:
        return pd.DataFrame()
    p = pd.DataFrame(prices, columns=["ts","price"])
    v = pd.DataFrame(vols,   columns=["ts","vol"])
    df = p.merge(v, on="ts", how="left")
    df["Date"] = pd.to_datetime(df["ts"], unit="ms", utc=True).dt.tz_convert("UTC").dt.tz_localize(None)
    df = df.set_index("Date").sort_index()
    df = df.rename(columns={"price":"Close","vol":"DollarVolume"})
    df["Open"] = df["Close"]; df["High"] = df["Close"]; df["Low"] = df["Close"]
    df["VolumeFrom"] = (df["DollarVolume"] / df["Close"]).replace([np.inf,-np.inf], np.nan)
    df["VolumeTo"]   = df["DollarVolume"]
    return df[["Open","High","Low","Close","VolumeFrom","VolumeTo"]]

def _cache_path(sym, tsym="USD"):
    return os.path.join(CACHE_DIR, f"{sym}_{tsym}_coingecko.parquet")

def get_ohlcv_cg_cached(symbol, start="2021-01-01"):
    path = _cache_path(symbol, "USD")
    if os.path.exists(path):
        try:
            df = pd.read_parquet(path)
            # small top-up to catch revisions
            try:
                cg_id = cg_get_id(symbol)
                if cg_id:
                    fresh = cg_market_chart_df(cg_id, "usd").last("20D")
                    df = pd.concat([df, fresh]).sort_index()
                    df = df[~df.index.duplicated(keep="last")]
                    df.to_parquet(path)
            except Exception:
                pass
            return df[df.index >= pd.to_datetime(start)]
        except Exception:
            pass
    cg_id = cg_get_id(symbol)
    if not cg_id:
        raise RuntimeError(f"Could not resolve CoinGecko id for symbol '{symbol}'. Add it to COINGECKO_IDS.")
    df = cg_market_chart_df(cg_id, "usd")
    if not df.empty:
        try: df.to_parquet(path)
        except Exception: pass
    return df[df.index >= pd.to_datetime(start)]

def get_ohlcv(symbol, start="2021-01-01"):
    return get_ohlcv_cg_cached(symbol, start=start)

# -------------------------------- Indicators --------------------------------
def ema(s, n): return s.ewm(span=n, adjust=False).mean()

def rsi(series, length=14):
    s = series.astype(float); d = s.diff()
    up = np.where(d > 0, d, 0.0); dn = np.where(d < 0, -d, 0.0)
    up_ewm = pd.Series(up, index=s.index).ewm(alpha=1/length, adjust=False).mean()
    dn_ewm = pd.Series(dn, index=s.index).ewm(alpha=1/length, adjust=False).mean()
    rs = up_ewm / (dn_ewm.replace(0, np.nan))
    return (100 - (100 / (1 + rs))).fillna(0)

def sharpe(r, ppy=365):
    r = r.dropna()
    if r.empty: return 0.0
    sd = r.std(ddof=0)
    return 0.0 if sd==0 or np.isnan(sd) else (r.mean()/sd)*math.sqrt(ppy)

# -------------------------------- Alignment --------------------------------
def load_universe(symbols, start):
    frames, failed = {}, []
    for sym in symbols:
        try:
            df = get_ohlcv(sym, start=start)
            if df is None or df.empty: failed.append(sym)
            else: frames[sym] = df
        except Exception as e:
            failed.append(sym); log(f"FAIL {sym}: {e}")
        # keep within CG limits
        sleep = PER_REQUEST_DELAY_S * (1.0 + 0.25*random.random())
        time.sleep(sleep)
    if failed: log(f"Skipped (no market / error): {failed}")
    if not frames: raise RuntimeError("No symbols had valid markets on CoinGecko.")
    return frames

def align_panel(frames):
    all_idx = None
    for df in frames.values():
        all_idx = df.index if all_idx is None else all_idx.union(df.index)
    all_idx = all_idx.sort_values(); cols = list(frames.keys())
    C = pd.DataFrame(index=all_idx, columns=cols, dtype=float)
    H = pd.DataFrame(index=all_idx, columns=cols, dtype=float)
    L = pd.DataFrame(index=all_idx, columns=cols, dtype=float)
    V = pd.DataFrame(index=all_idx, columns=cols, dtype=float)
    VT= pd.DataFrame(index=all_idx, columns=cols, dtype=float)
    for sym, df in frames.items():
        C.loc[df.index, sym]  = df["Close"].astype(float)
        H.loc[df.index, sym]  = df["High"].astype(float)
        L.loc[df.index, sym]  = df["Low"].astype(float)
        V.loc[df.index, sym]  = df["VolumeFrom"].astype(float)
        VT.loc[df.index, sym] = df["VolumeTo"].astype(float)
    return C,H,L,V,VT

# -------------------------------- Core helpers --------------------------------
def exposure_from_breadth(breadth_pct, bmin=BREADTH_MIN, bfull=BREADTH_FULL):
    if bfull <= bmin: return 0.0
    x = (breadth_pct - bmin) / (bfull - bmin)
    return float(np.clip(x, 0.0, 1.0))

def entry_checks_for_day(idx, C,H,L,V, ema20,ema50, rsi3,rsi14, r7, r10, sh7, ema_diff):
    checks = {
        ">EMA20":   (C.loc[idx] > ema20.loc[idx]),
        "RSI3>55":  (rsi3.loc[idx] > 55),
        "RSI14>50": (rsi14.loc[idx] > 50),
        "ROC10>0":  (r10.loc[idx] > 0),
        "7d>0":     (r7.loc[idx]  > 0),
        "Sharpe+":  (sh7.loc[idx] > 0),
        "EMA+":     (ema_diff.loc[idx] > 0),
    }
    df = pd.DataFrame(checks)
    entry_pct = df.mean(axis=1) * 100.0
    return df, entry_pct

def compute_score_parts(idx, df_day):
    def pct_rank(s):
        s = pd.Series(s).replace([np.inf,-np.inf], np.nan)
        return s.rank(pct=True, method="average")
    w = {"r7":0.18,"r14":0.18,"mom":0.18,"rsi_med":0.14,"sh7":0.14,"ema":0.12,"voltr":0.06}
    parts = {
        "r7": pct_rank(df_day["7d Return"]),
        "r14": pct_rank(df_day["14d Return"]),
        "mom": pct_rank(df_day["Momentum"]),
        "rsi_med": pct_rank(df_day["RSI Med"]),
        "sh7": pct_rank(df_day["Sharpe 7d"]),
        "ema": pct_rank(df_day["EMA Diff"]),
        "voltr": pct_rank(df_day["Vol. Trend"])
    }
    score = sum(parts[k]*w[k] for k in w) * 100.0
    return score

# -------------------------------- Screener --------------------------------
def build_table_today(C,H,L,V,VT):
    ret1 = C.pct_change()
    r3  = C.pct_change(3);  r7  = C.pct_change(7);  r14 = C.pct_change(14)
    r10 = C.pct_change(10)
    rsi3  = C.apply(lambda s: rsi(s, 3));  rsi14 = C.apply(lambda s: rsi(s,14))
    ema20 = C.apply(lambda s: ema(s,20));  ema50 = C.apply(lambda s: ema(s,50))
    v7 = V.rolling(7).mean(); v28 = V.rolling(28).mean(); vol_trend = (v7/v28 - 1.0)
    sh7 = ret1.rolling(7).apply(lambda x: sharpe(pd.Series(x)), raw=False)
    ema_diff = (C/ema50 - 1.0) * 100.0
    dv14 = VT.rolling(ROLL_VOL_DAYS).sum()

    today = C.index[-1]; yday = C.index[-2] if len(C.index) >= 2 else today

    dv_today = dv14.loc[today].dropna().sort_values(ascending=False)
    top_syms = list(dv_today.index[:TOP_K_DOLLAR_VOL])
    if not top_syms: raise RuntimeError("No symbols have dollar-volume; check API responses.")

    _, entry_pct_today = entry_checks_for_day(today, C,H,L,V, ema20,ema50, rsi3,rsi14, r7, r10, sh7, ema_diff)
    _, entry_pct_prev  = entry_checks_for_day(yday,  C,H,L,V, ema20,ema50, rsi3,rsi14, r7, r10, sh7, ema_diff)

    entry_pct_today = entry_pct_today.reindex(top_syms)
    entry_pct_prev  = entry_pct_prev.reindex(top_syms)
    coin_risk = np.where(entry_pct_today >= ENTRY_OK_THRESHOLD, "RISK_ON", "RISK_OFF")

    df = pd.DataFrame(index=top_syms)
    df["Token"]      = [sym + "USDT" for sym in top_syms]
    df["3d Return"]  = r3.loc[today, top_syms].values * 100
    df["7d Return"]  = r7.loc[today, top_syms].values * 100
    df["14d Return"] = r14.loc[today, top_syms].values * 100
    df["RSI Short"]  = rsi3.loc[today, top_syms].values
    df["RSI Med"]    = rsi14.loc[today, top_syms].values
    df["Vol. Trend"] = vol_trend.loc[today, top_syms].values
    df["Momentum"]   = r10.loc[today, top_syms].values
    df["Sharpe 7d"]  = sh7.loc[today, top_syms].values
    df["EMA Diff"]   = ema_diff.loc[today, top_syms].values
    df["Close"]      = C.loc[today, top_syms].values
    df["Entry %"]    = entry_pct_today.values
    df["Risk Gauge"] = coin_risk

    df["Score"] = compute_score_parts(today, df).values
    conf = CONF_BLEND_ENTRY*df["Entry %"].clip(0,100) + (1.0-CONF_BLEND_ENTRY)*df["Score"].clip(0,100)
    df["Confidence %"] = conf.values

    prev_pass = (entry_pct_prev >= ENTRY_OK_THRESHOLD).fillna(False)
    curr_pass = (entry_pct_today >= ENTRY_OK_THRESHOLD).fillna(False)
    signal = np.where(curr_pass & ~prev_pass, "BUY",
                      np.where(curr_pass & prev_pass, "HOLD",
                               np.where(~curr_pass & prev_pass, "SELL", "NO TRADE")))
    df["Signal"] = signal

    breadth_pct = float((df["Entry %"] >= ENTRY_OK_THRESHOLD).mean()*100.0)
    exposure = exposure_from_breadth(breadth_pct)

    eligible = (df["Risk Gauge"] == "RISK_ON")
    raw = pd.Series(0.0, index=df.index)
    if eligible.any():
        raw_elig = (df.loc[eligible, "Confidence %"] / 100.0) ** CONF_EXPONENT
        raw_elig = raw_elig / raw_elig.sum() if raw_elig.sum() > 0 else raw_elig
        wts = (raw_elig * 100.0).clip(0, MAX_WEIGHT_PCT)
        total = wts.sum()
        if total > 0: wts = wts * (100.0 / total)
        raw.loc[wts.index] = wts.values
    final_w = (raw * (exposure * 100.0)).where(lambda s: s >= MIN_SHOW_WEIGHT, 0.0)
    df["Suggested Wt %"] = final_w.values

    df = df.sort_values(by=["Confidence %","Score","Entry %"], ascending=False)
    df.insert(0, "Rank", range(1, len(df)+1))

    pct_cols = ["3d Return","7d Return","14d Return","EMA Diff","Entry %","Score","Confidence %","Suggested Wt %"]
    for c in pct_cols:
        if c in df.columns: df[c] = df[c].round(2)
    for c in ["RSI Short","RSI Med","Sharpe 7d","Momentum","Vol. Trend","Close"]:
        if c in df.columns: df[c] = df[c].round(2)

    meta = {"today": today, "breadth": breadth_pct, "exposure": exposure, "alloc_sum": float(df["Suggested Wt %"].sum())}
    df = df[["Rank","Token","Signal","Score","Entry %","Risk Gauge","3d Return","7d Return","14d Return",
             "RSI Short","RSI Med","Vol. Trend","Momentum","Sharpe 7d","EMA Diff","Close","Confidence %","Suggested Wt %"]]
    return df, meta

# -------------------------------- Backtest (unchanged) --------------------------------
def backtest(C,H,L,V,VT, start=None, end=None):
    ret1 = C.pct_change()
    r7  = C.pct_change(7);  r14 = C.pct_change(14);  r10 = C.pct_change(10)
    rsi3  = C.apply(lambda s: rsi(s, 3));  rsi14 = C.apply(lambda s: rsi(s,14))
    ema20 = C.apply(lambda s: ema(s,20));  ema50 = C.apply(lambda s: ema(s,50))
    v7 = V.rolling(7).mean(); v28 = V.rolling(28).mean()
    sh7 = ret1.rolling(7).apply(lambda x: sharpe(pd.Series(x)), raw=False)
    ema_diff = (C/ema50 - 1.0) * 100.0
    dv14 = VT.rolling(ROLL_VOL_DAYS).sum()

    dates = C.index
    if start: dates = dates[dates >= pd.to_datetime(start)]
    if end:   dates = dates[dates <= pd.to_datetime(end)]
    if len(dates) < 30: raise RuntimeError("Backtest window too short.")

    equity = pd.Series(index=dates, dtype=float); equity.iloc[0] = 1.0
    for i in range(1, len(dates)):
        d = dates[i]
        dv_today = dv14.loc[d].dropna().sort_values(ascending=False)
        top = list(dv_today.index[:TOP_K_DOLLAR_VOL])

        df_day = pd.DataFrame(index=top)
        df_day["7d Return"]  = r7.loc[d, top].values * 100
        df_day["14d Return"] = r14.loc[d, top].values * 100
        df_day["Momentum"]   = r10.loc[d, top].values
        df_day["RSI Med"]    = rsi14.loc[d, top].values
        df_day["Sharpe 7d"]  = sh7.loc[d, top].values
        df_day["EMA Diff"]   = ema_diff.loc[d, top].values
        df_day["Vol. Trend"] = (v7.loc[d, top] / v28.loc[d, top] - 1.0).values

        _, entry_today = entry_checks_for_day(d, C,H,L,V, ema20,ema50, rsi3,rsi14, r7, r10, sh7, ema_diff)
        entry_today = entry_today.reindex(top)
        risk_on = (entry_today >= ENTRY_OK_THRESHOLD)

        breadth = float(risk_on.mean()*100.0) if len(risk_on) else 0.0
        exposure = exposure_from_breadth(breadth)

        score = compute_score_parts(d, df_day)
        confidence = CONF_BLEND_ENTRY*entry_today.clip(0,100) + (1.0-CONF_BLEND_ENTRY)*score.clip(0,100)

        w = pd.Series(0.0, index=C.columns)
        elig_conf = confidence[risk_on].dropna()
        if len(elig_conf) > 0:
            raw = (elig_conf/100.0) ** CONF_EXPONENT
            raw = raw / raw.sum() if raw.sum() > 0 else raw
            w_elig = (raw * 100.0).clip(0, MAX_WEIGHT_PCT)
            tot = w_elig.sum()
            if tot > 0: w_elig = w_elig * (100.0/tot)
            w.loc[w_elig.index] = w_elig.values

        w = (w * exposure) / 100.0
        r = ret1.loc[d].fillna(0.0)
        port_ret = float(np.nansum(w * r))
        equity.iloc[i] = equity.iloc[i-1] * (1.0 + port_ret)

    equity = equity.dropna()

    try:
        btc = get_ohlcv("BTC", start=str(dates.min().date()))["Close"].reindex(dates).ffill()
        btc_eq = btc / btc.iloc[0]
    except Exception:
        btc_eq = None

    daily = equity.pct_change().dropna()
    def drawdown_curve(x): return x/x.cummax() - 1.0
    total_ret = equity.iloc[-1] - 1.0
    cagr = (equity.iloc[-1]) ** (365.0/len(equity)) - 1.0 if len(equity)>1 else 0.0
    sh   = sharpe(daily)
    neg  = daily[daily<0]
    so   = (daily.mean()/neg.std(ddof=0))*math.sqrt(365) if len(neg)>0 and neg.std(ddof=0)>0 else 0.0
    mdd  = drawdown_curve(equity).min()
    stats = {"TotalReturn": float(total_ret), "CAGR": float(cagr), "Sharpe": float(sh), "Sortino": float(so), "MaxDD": float(mdd)}
    return equity, btc_eq, stats

# -------------------------------- Styling + PNG (unchanged) --------------------------------
# ... (same style_table and save_table_png from your current file — unchanged for brevity) ...

# ---------- Paste your existing style_table(...) and save_table_png(...) blocks here unchanged ----------

# -------------------------------- MAIN --------------------------------
def main():
    log("Downloading daily data from CoinGecko (key + retry) …")
    frames = load_universe(MEME_TICKERS, start=LOOKBACK_START)
    C,H,L,V,VT = align_panel(frames)

    # Drop today's partial candle if running before UTC close
    if C.index[-1].date() == date.today():
        C = C.iloc[:-1]; H = H.iloc[:-1]; L = L.iloc[:-1]; V = V.iloc[:-1]; VT = VT.iloc[:-1]

    coverage = C.notna().mean().mean()
    log(f"Average price coverage: {coverage*100:.1f}%")

    # Table
    table, meta = build_table_today(C,H,L,V,VT)
    table.to_csv(OUT_CSV, index=False)

    # --- render styled HTML + PNG
    styled = style_table(table, meta)  # uses your existing function
    with open(OUT_HTML, "w", encoding="utf-8") as f: f.write(styled.to_html())
    save_table_png(table, meta, OUT_TABLE_PNG, max_rows=TOP_K_DOLLAR_VOL)

    # Backtest
    if RUN_BACKTEST:
        eq, btc_eq, stats = backtest(C,H,L,V,VT, start=BACKTEST_START, end=BACKTEST_END)
        plt.figure(figsize=(11,5.8))
        plt.plot(eq.index, eq.values, label="RSPS (hybrid)")
        if btc_eq is not None:
            plt.plot(eq.index, btc_eq.reindex(eq.index).values, label="BTC HODL")
        plt.yscale("log")
        plt.title(f"RSPS vs BTC (log scale) — {BACKTEST_START} → {eq.index[-1].date()}")
        plt.xlabel("Date"); plt.ylabel("Equity (log)")
        box = (
            f"Total: {stats['TotalReturn']*100:.1f}%\n"
            f"CAGR:  {stats['CAGR']*100:.1f}%\n"
            f"Sharpe:{stats['Sharpe']:.2f}\n"
            f"Sort.: {stats['Sortino']:.2f}\n"
            f"MaxDD: {stats['MaxDD']*100:.1f}%"
        )
        plt.legend()
        plt.gcf().text(0.78, 0.50, box, fontsize=10,
                       bbox=dict(boxstyle="round", facecolor="#111", edgecolor="#444"),
                       color="#ddd")
        plt.tight_layout(); plt.savefig(OUT_BACKTEST_PNG, dpi=150); plt.close()
        log(f"Saved backtest PNG -> {os.path.abspath(OUT_BACKTEST_PNG)}")

    # Console summary
    print("\n===== Meme Screener —", meta['today'].date(), "=====")
    print(f"Breadth (Entry%≥{ENTRY_OK_THRESHOLD:.0f}%): {meta['breadth']:.1f}%  |  "
          f"Exposure: {meta['exposure']*100:.0f}%  |  Total Alloc: {meta['alloc_sum']:.1f}%")
    print(table.to_string(index=False))
    print("\nSaved:", OUT_CSV, "|", OUT_HTML, "|", OUT_TABLE_PNG, "|", (OUT_BACKTEST_PNG if RUN_BACKTEST else ""))

if __name__ == "__main__":
    main()


































