# Meme-Coin Daily Screener â€” Hybrid Risk + BUY/HOLD/SELL + Backtest + Color-coded table
# Backtest period: 2021-01-01 â†’ today, compare vs BTC buy&hold (log chart)
# Metrics shown: %Return, CAGR, Sharpe, Sortino, MaxDD

import os, time, math, random, webbrowser
from datetime import datetime
import numpy as np
import pandas as pd
import requests

# ============================= CONFIG =============================
MEME_TICKERS = [
    "DOGE","SHIB","PEPE","FLOKI","BONK","WIF","BOME","POPCAT","PONKE","MEW","MYRO","MOG","WOJAK","MAGA","TURBO","AIDOGE","ELON","PORK","LADYS","KISHU","AKITA","HOGE","PEPE2",
    "BNB","APE","ZEC","DASH","ZEN","ALU"
]

LOOKBACK_START   = "2021-01-01"   # pull history starting 2021 for backtest
TOP_K_DOLLAR_VOL = 25
ROLL_VOL_DAYS    = 14

# ---- Hybrid risk / allocation knobs ----
ENTRY_OK_THRESHOLD = 60.0   # RISK_ON if Entry% >= this (â‰ˆ 5 of 7 checks)
BREADTH_MIN        = 20.0   # exposure = 0% at this breadth
BREADTH_FULL       = 50.0   # exposure = 100% at this breadth
CONF_BLEND_ENTRY   = 0.50   # Confidence = 0.5*Entry% + 0.5*Score
CONF_EXPONENT      = 1.25   # concentrates into strongest names
MAX_WEIGHT_PCT     = 25.0   # per-name cap BEFORE exposure scaling
MIN_SHOW_WEIGHT    = 0.25   # hide dust weights below this in table

# ---- Output files ----
OUT_HTML = "meme_screener_daily.html"
OUT_CSV  = "meme_screener_daily.csv"
OUT_PNG  = "meme_rsps_backtest.png"     # equity chart (log scale)
OPEN_AFTER_SAVE = True
RUN_BACKTEST    = True

# Backtest window (can override; None = use all available)
BACKTEST_START = "2021-01-01"
BACKTEST_END   = None  # e.g., "2025-10-19"

# ðŸ”‘ CryptoCompare key (ENV overrides). Your key is embedded by request.
DEFAULT_CRYPTOCOMPARE_API_KEY = "d5ddb7a7f49de4d4a8af07e98e0ebf437e7acc8bb282f12af978320486f741e7"

# Robust fetching
EXCHANGES_TRY = ["BINANCE","BYBIT","OKX","KUCOIN","BITGET","GATEIO","KRAKEN","COINBASE", None]  # None=CCCAGG
PAIR_CACHE = {}
MAX_RETRIES = 6
BASE_SLEEP  = 1.2
SESSION     = requests.Session()

np.set_printoptions(suppress=True)
pd.set_option("display.width", 180)
pd.set_option("display.max_columns", 50)

# ============================= UTILS / CRYPTOCOMPARE =============================
def log(msg): print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] {msg}")

def cc_headers():
    api_key = os.getenv("CRYPTOCOMPARE_API_KEY", "").strip() or DEFAULT_CRYPTOCOMPARE_API_KEY.strip()
    if not api_key: raise RuntimeError("CRYPTOCOMPARE_API_KEY missing (env or embedded).")
    return {"authorization": f"Apikey {api_key}"}

def _is_no_market(j) -> bool:
    msg = (j or {}).get("Message","").lower()
    return any(k in msg for k in ["market does not exist","pair not found","there is no data"])

def cc_histoday_page_with(sym, tsym="USD", exchange=None, limit=2000, toTs=None):
    url = "https://min-api.cryptocompare.com/data/v2/histoday"
    params = {"fsym": sym, "tsym": tsym, "limit": min(2000, limit)}
    if toTs is not None: params["toTs"] = int(toTs)
    if exchange: params["e"] = exchange
    headers = cc_headers()
    last_err = None
    for k in range(MAX_RETRIES):
        try:
            r = SESSION.get(url, params=params, headers=headers, timeout=30)
            if r.status_code == 429:
                wait = BASE_SLEEP*(2**k) + random.uniform(0,0.6)
                log(f"429 {sym}-{tsym}@{exchange or 'CCCAGG'}; sleep {wait:.1f}s"); time.sleep(wait); continue
            r.raise_for_status()
            data = r.json()
            if data.get("Response") != "Success":
                if _is_no_market(data): return None
                last_err = RuntimeError(data.get("Message","Unknown CC error"))
                wait = BASE_SLEEP*(2**k) + random.uniform(0,0.6)
                log(f"CC bad resp {sym}-{tsym}@{exchange}: {last_err} (retry {k+1}/{MAX_RETRIES}, {wait:.1f}s)")
                time.sleep(wait); continue
            df = pd.DataFrame(data["Data"]["Data"])
            if df.empty: return pd.DataFrame()
            df["Date"] = pd.to_datetime(df["time"], unit="s", utc=True).dt.tz_convert("UTC").dt.tz_localize(None)
            df = df.set_index("Date").rename(columns={
                "open":"Open","high":"High","low":"Low","close":"Close",
                "volumefrom":"VolumeFrom","volumeto":"VolumeTo"
            })
            return df
        except Exception as e:
            last_err = e
            wait = BASE_SLEEP*(2**k) + random.uniform(0,0.6)
            log(f"CC error {sym}-{tsym}@{exchange}: {e} (retry {k+1}/{MAX_RETRIES}, {wait:.1f}s)")
            time.sleep(wait)
    raise RuntimeError(f"Failed CC histoday for {sym}-{tsym}@{exchange}: {last_err}")

def cc_histoday_full_with(sym, tsym="USD", exchange=None, start="2020-01-01"):
    target = pd.to_datetime(start)
    df = cc_histoday_page_with(sym, tsym=tsym, exchange=exchange, limit=2000)
    if df is None or df.empty: return pd.DataFrame()
    df = df.sort_index()
    earliest = df.index.min()
    while earliest > target:
        toTs = int(earliest.timestamp()) - 86400
        older = cc_histoday_page_with(sym, tsym=tsym, exchange=exchange, limit=2000, toTs=toTs)
        if older is None or older.empty: break
        df = pd.concat([older, df], axis=0)
        df = df[~df.index.duplicated(keep="first")].sort_index()
        earliest = df.index.min()
        time.sleep(0.08)
    return df[df.index >= pd.to_datetime(start)]

def resolve_pair_and_fetch(sym, start="2020-01-01"):
    if sym in PAIR_CACHE:
        conf = PAIR_CACHE[sym]; return cc_histoday_full_with(sym, conf["tsym"], conf["e"], start), conf
    for tsym in ("USD","USDT"):
        for ex in EXCHANGES_TRY:
            df0 = cc_histoday_page_with(sym, tsym=tsym, exchange=ex, limit=2000)
            if df0 is None: continue
            if isinstance(df0, pd.DataFrame) and not df0.empty:
                df_full = cc_histoday_full_with(sym, tsym, ex, start)
                PAIR_CACHE[sym] = {"tsym": tsym, "e": ex}; tag = ex or "CCCAGG"
                log(f"OK {sym}-{tsym}@{tag}: {len(df_full)} rows"); return df_full, PAIR_CACHE[sym]
    log(f"UNSUPPORTED on CC: {sym} (skipping)"); return pd.DataFrame(), None

def get_ohlcv(symbol, start="2020-01-01"):
    df, _ = resolve_pair_and_fetch(symbol, start=start); return df

# ============================= INDICATORS =============================
def ema(s, n): return s.ewm(span=n, adjust=False).mean()

def rsi(series, length=14):
    s = series.astype(float); d = s.diff()
    up = np.where(d > 0, d, 0.0); dn = np.where(d < 0, -d, 0.0)
    up_ewm = pd.Series(up, index=s.index).ewm(alpha=1/length, adjust=False).mean()
    dn_ewm = pd.Series(dn, index=s.index).ewm(alpha=1/length, adjust=False).mean()
    rs = up_ewm / (dn_ewm.replace(0, np.nan))
    return (100 - (100 / (1 + rs))).fillna(0)

def sharpe(r, ppy=365):
    r = r.dropna()
    if r.empty: return 0.0
    sd = r.std(ddof=0)
    return 0.0 if sd==0 or np.isnan(sd) else (r.mean()/sd)*math.sqrt(ppy)

# ============================= DATA ALIGNMENT =============================
def load_universe(symbols, start):
    frames, failed = {}, []
    for sym in symbols:
        try:
            df = get_ohlcv(sym, start=start)
            if df is None or df.empty: failed.append(sym); continue
            frames[sym] = df; time.sleep(0.05)
        except Exception as e:
            failed.append(sym); log(f"FAIL {sym}: {e}")
    if failed: log(f"Skipped (no market / error): {failed}")
    if not frames: raise RuntimeError("No symbols had valid markets on CryptoCompare.")
    return frames

def align_panel(frames):
    all_idx = None
    for df in frames.values():
        all_idx = df.index if all_idx is None else all_idx.union(df.index)
    all_idx = all_idx.sort_values(); cols = list(frames.keys())
    C = pd.DataFrame(index=all_idx, columns=cols, dtype=float)
    H = pd.DataFrame(index=all_idx, columns=cols, dtype=float)
    L = pd.DataFrame(index=all_idx, columns=cols, dtype=float)
    V = pd.DataFrame(index=all_idx, columns=cols, dtype=float)
    VT= pd.DataFrame(index=all_idx, columns=cols, dtype=float)
    for sym, df in frames.items():
        C.loc[df.index, sym]  = df["Close"].astype(float)
        H.loc[df.index, sym]  = df["High"].astype(float)
        L.loc[df.index, sym]  = df["Low"].astype(float)
        V.loc[df.index, sym]  = df["VolumeFrom"].astype(float)
        VT.loc[df.index, sym] = df["VolumeTo"].astype(float)
    return C,H,L,V,VT

# ============================= CORE LOGIC HELPERS =============================
def exposure_from_breadth(breadth_pct, bmin=BREADTH_MIN, bfull=BREADTH_FULL):
    if bfull <= bmin: return 0.0
    x = (breadth_pct - bmin) / (bfull - bmin)
    return float(np.clip(x, 0.0, 1.0))

def entry_checks_for_day(idx, C,H,L,V, ema20,ema50, rsi3,rsi14, r7, r10, sh7, ema_diff):
    checks = {}
    checks[">EMA20"]   = (C.loc[idx] > ema20.loc[idx])
    checks["RSI3>55"]  = (rsi3.loc[idx] > 55)
    checks["RSI14>50"] = (rsi14.loc[idx] > 50)
    checks["ROC10>0"]  = (r10.loc[idx] > 0)
    checks["7d>0"]     = (r7.loc[idx]  > 0)
    checks["Sharpe+"]  = (sh7.loc[idx] > 0)
    checks["EMA+"]     = (ema_diff.loc[idx] > 0)
    df = pd.DataFrame(checks)
    entry_pct = df.mean(axis=1) * 100.0
    return df, entry_pct

def compute_score_parts(idx, df_day):
    def pct_rank(s):
        s = pd.Series(s).replace([np.inf,-np.inf], np.nan)
        return s.rank(pct=True, method="average")
    w = {"r7":0.18,"r14":0.18,"mom":0.18,"rsi_med":0.14,"sh7":0.14,"ema":0.12,"voltr":0.06}
    parts = {
        "r7": pct_rank(df_day["7d Return"]),
        "r14": pct_rank(df_day["14d Return"]),
        "mom": pct_rank(df_day["Momentum"]),
        "rsi_med": pct_rank(df_day["RSI Med"]),
        "sh7": pct_rank(df_day["Sharpe 7d"]),
        "ema": pct_rank(df_day["EMA Diff"]),
        "voltr": pct_rank(df_day["Vol. Trend"])
    }
    score = sum(parts[k]*w[k] for k in w) * 100.0
    return score

# ============================= SCREENER (today) =============================
def build_table_today(C,H,L,V,VT):
    ret1 = C.pct_change()
    r3  = C.pct_change(3);  r7  = C.pct_change(7);  r14 = C.pct_change(14)
    r10 = C.pct_change(10)
    rsi3  = C.apply(lambda s: rsi(s, 3));  rsi14 = C.apply(lambda s: rsi(s,14))
    ema20 = C.apply(lambda s: ema(s,20));  ema50 = C.apply(lambda s: ema(s,50))
    v7 = V.rolling(7).mean(); v28 = V.rolling(28).mean(); vol_trend = (v7/v28 - 1.0)
    sh7 = ret1.rolling(7).apply(lambda x: sharpe(pd.Series(x)), raw=False)
    ema_diff = (C/ema50 - 1.0) * 100.0
    dv14 = VT.rolling(ROLL_VOL_DAYS).sum()

    today = C.index[-1]; yday = C.index[-2] if len(C.index) >= 2 else today

    dv_today = dv14.loc[today].dropna().sort_values(ascending=False)
    top_syms = list(dv_today.index[:TOP_K_DOLLAR_VOL])
    if not top_syms: raise RuntimeError("No symbols have dollar-volume; check API responses.")

    # Entry% today & yesterday
    _, entry_pct_today = entry_checks_for_day(today, C,H,L,V, ema20,ema50, rsi3,rsi14, r7, r10, sh7, ema_diff)
    _, entry_pct_prev  = entry_checks_for_day(yday,  C,H,L,V, ema20,ema50, rsi3,rsi14, r7, r10, sh7, ema_diff)

    entry_pct_today = entry_pct_today.reindex(top_syms)
    entry_pct_prev  = entry_pct_prev.reindex(top_syms)

    coin_risk = np.where(entry_pct_today >= ENTRY_OK_THRESHOLD, "RISK_ON", "RISK_OFF")

    # Base rows
    df = pd.DataFrame(index=top_syms)
    df["Token"]      = [sym + "USDT" for sym in top_syms]
    df["3d Return"]  = r3.loc[today, top_syms].values * 100
    df["7d Return"]  = r7.loc[today, top_syms].values * 100
    df["14d Return"] = r14.loc[today, top_syms].values * 100
    df["RSI Short"]  = rsi3.loc[today, top_syms].values
    df["RSI Med"]    = rsi14.loc[today, top_syms].values
    df["Vol. Trend"] = vol_trend.loc[today, top_syms].values
    df["Momentum"]   = r10.loc[today, top_syms].values
    df["Sharpe 7d"]  = sh7.loc[today, top_syms].values
    df["EMA Diff"]   = ema_diff.loc[today, top_syms].values
    df["Close"]      = C.loc[today, top_syms].values
    df["Entry %"]    = entry_pct_today.values
    df["Risk Gauge"] = coin_risk

    # Score & Confidence
    df["Score"] = compute_score_parts(today, df).values
    conf = CONF_BLEND_ENTRY*df["Entry %"].clip(0,100) + (1.0-CONF_BLEND_ENTRY)*df["Score"].clip(0,100)
    df["Confidence %"] = conf.values

    # BUY / HOLD / SELL
    prev_pass = (entry_pct_prev >= ENTRY_OK_THRESHOLD).fillna(False)
    curr_pass = (entry_pct_today >= ENTRY_OK_THRESHOLD).fillna(False)
    signal = np.where(curr_pass & ~prev_pass, "BUY",
                      np.where(curr_pass & prev_pass, "HOLD",
                               np.where(~curr_pass & prev_pass, "SELL", "NO TRADE")))
    df["Signal"] = signal

    # Breadth / exposure
    breadth_pct = float((df["Entry %"] >= ENTRY_OK_THRESHOLD).mean()*100.0)
    exposure = exposure_from_breadth(breadth_pct)

    # Weights among eligible
    eligible = (df["Risk Gauge"] == "RISK_ON")
    raw = pd.Series(0.0, index=df.index)
    if eligible.any():
        raw_elig = (df.loc[eligible, "Confidence %"] / 100.0) ** CONF_EXPONENT
        raw_elig = raw_elig / raw_elig.sum() if raw_elig.sum() > 0 else raw_elig
        wts = (raw_elig * 100.0).clip(0, MAX_WEIGHT_PCT)
        total = wts.sum()
        if total > 0: wts = wts * (100.0 / total)
        raw.loc[wts.index] = wts.values
    final_w = (raw * (exposure * 100.0)).where(lambda s: s >= MIN_SHOW_WEIGHT, 0.0)
    df["Suggested Wt %"] = final_w.values

    # Rank and order
    df = df.sort_values(by=["Confidence %","Score","Entry %"], ascending=False)
    df.insert(0, "Rank", range(1, len(df)+1))
    round_pct_cols = ["3d Return","7d Return","14d Return","EMA Diff","Entry %","Score","Confidence %","Suggested Wt %"]
    df[round_pct_cols] = df[round_pct_cols].round(2)
    df[["RSI Short","RSI Med","Sharpe 7d","Momentum","Vol. Trend","Close"]] = \
        df[["RSI Short","RSI Med","Sharpe 7d","Momentum","Vol. Trend","Close"]].round(2)

    meta = {
        "today": today,
        "breadth": breadth_pct,
        "exposure": exposure,
        "alloc_sum": float(df["Suggested Wt %"].sum())
    }
    # Final layout
    df = df[["Rank","Token","Signal","Score","Entry %","Risk Gauge","3d Return","7d Return","14d Return",
             "RSI Short","RSI Med","Vol. Trend","Momentum","Sharpe 7d","EMA Diff","Close","Confidence %","Suggested Wt %"]]
    return df, meta

# ============================= BACKTEST =============================
def backtest(C,H,L,V,VT, start=None, end=None):
    """Daily rebalance backtest using the same rules as the screener.
       start/end are date strings like '2021-01-01' (inclusive)."""
    ret1 = C.pct_change()
    r7  = C.pct_change(7);  r14 = C.pct_change(14);  r10 = C.pct_change(10)
    rsi3  = C.apply(lambda s: rsi(s, 3));  rsi14 = C.apply(lambda s: rsi(s,14))
    ema20 = C.apply(lambda s: ema(s,20));  ema50 = C.apply(lambda s: ema(s,50))
    v7 = V.rolling(7).mean(); v28 = V.rolling(28).mean()
    sh7 = ret1.rolling(7).apply(lambda x: sharpe(pd.Series(x)), raw=False)
    ema_diff = (C/ema50 - 1.0) * 100.0
    dv14 = VT.rolling(ROLL_VOL_DAYS).sum()

    # Restrict to backtest window
    dates = C.index
    if start: dates = dates[dates >= pd.to_datetime(start)]
    if end:   dates = dates[dates <= pd.to_datetime(end)]
    if len(dates) < 30: raise RuntimeError("Backtest window too short.")

    equity = pd.Series(index=dates, dtype=float)
    equity.iloc[0] = 1.0

    for i in range(1, len(dates)):
        d = dates[i]
        # universe today
        dv_today = dv14.loc[d].dropna().sort_values(ascending=False)
        top = list(dv_today.index[:TOP_K_DOLLAR_VOL])

        # day frame for score
        df_day = pd.DataFrame(index=top)
        df_day["7d Return"]  = r7.loc[d, top].values * 100
        df_day["14d Return"] = r14.loc[d, top].values * 100
        df_day["Momentum"]   = r10.loc[d, top].values
        df_day["RSI Med"]    = rsi14.loc[d, top].values
        df_day["Sharpe 7d"]  = sh7.loc[d, top].values
        df_day["EMA Diff"]   = ema_diff.loc[d, top].values
        df_day["Vol. Trend"] = (v7.loc[d, top] / v28.loc[d, top] - 1.0).values

        # Entry% today
        _, entry_today = entry_checks_for_day(d, C,H,L,V, ema20,ema50, rsi3,rsi14, r7, r10, sh7, ema_diff)
        entry_today = entry_today.reindex(top)
        risk_on = (entry_today >= ENTRY_OK_THRESHOLD)

        # breadth & exposure
        breadth = float(risk_on.mean()*100.0) if len(risk_on) else 0.0
        exposure = exposure_from_breadth(breadth)

        # score + confidence
        score = compute_score_parts(d, df_day)
        confidence = CONF_BLEND_ENTRY*entry_today.clip(0,100) + (1.0-CONF_BLEND_ENTRY)*score.clip(0,100)

        # weights among eligible
        w = pd.Series(0.0, index=C.columns)
        elig_conf = confidence[risk_on].dropna()
        if len(elig_conf) > 0:
            raw = (elig_conf/100.0) ** CONF_EXPONENT
            raw = raw / raw.sum() if raw.sum() > 0 else raw
            w_elig = (raw * 100.0).clip(0, MAX_WEIGHT_PCT)
            tot = w_elig.sum()
            if tot > 0: w_elig = w_elig * (100.0/tot)
            w.loc[w_elig.index] = w_elig.values

        # scale by exposure -> daily target weights
        w = (w * exposure) / 100.0  # convert to 0..1 fractions

        # portfolio close-to-close return
        r = ret1.loc[d].fillna(0.0)
        port_ret = float(np.nansum(w * r))
        equity.iloc[i] = equity.iloc[i-1] * (1.0 + port_ret)

    equity = equity.dropna()

    # BTC buy&hold for reference over the same window
    try:
        btc = get_ohlcv("BTC", start=str(dates.min().date()))["Close"].reindex(dates).ffill()
        btc_eq = btc / btc.iloc[0]
    except Exception:
        btc_eq = None

    # Stats
    daily = equity.pct_change().dropna()
    def drawdown_curve(x):
        peak = x.cummax()
        return x/peak - 1.0

    total_ret = equity.iloc[-1] - 1.0
    cagr = (equity.iloc[-1]) ** (365.0/len(equity)) - 1.0 if len(equity)>1 else 0.0
    sh   = sharpe(daily)
    neg  = daily[daily<0]
    so   = (daily.mean()/neg.std(ddof=0))*math.sqrt(365) if len(neg)>0 and neg.std(ddof=0)>0 else 0.0
    mdd  = drawdown_curve(equity).min()

    stats = {"TotalReturn": total_ret, "CAGR": cagr, "Sharpe": sh, "Sortino": so, "MaxDD": mdd}
    return equity, btc_eq, stats

# ============================= HTML (color-coded, aesthetic) =============================
def style_table(df, meta):
    today = meta["today"]; breadth = meta["breadth"]; exposure = meta["exposure"]; alloc_sum = meta["alloc_sum"]
    caption = (
        f"Meme Screener â€” Top {len(df)} by 14d $Volume â€” {today.date()}  |  "
        f"Breadth(Entryâ‰¥{ENTRY_OK_THRESHOLD:.0f}%)={breadth:.1f}%  |  "
        f"Exposure Scale={exposure*100:.0f}%  |  Total Alloc={alloc_sum:.1f}%"
    )

    def bar_0_100(s, color="#0a0"):
        v = s.astype(float)/100.0
        return [f"background:linear-gradient(90deg,{color} {int(100*x)}%,#222 {int(100*x)}%); color:#ddd;" for x in v]

    def green_if_pos_red_if_neg(s):
        out=[]
        for x in s.astype(float):
            if np.isnan(x): out.append("")
            elif x > 0: out.append("background-color:#0a260a; color:#00d000;")
            else:       out.append("background-color:#2a0d0d; color:#ff6b6b;")
        return out

    def green_if_over(s, thr):
        out=[]
        for x in s.astype(float):
            if np.isnan(x): out.append("")
            elif x > thr:  out.append("background-color:#0a260a; color:#00d000;")
            else:          out.append("background-color:#2a0d0d; color:#ff6b6b;")
        return out

    # Brighter green/red boxes for Risk Gauge
    def risk_gauge_boxes(s):
        out=[]
        for v in s.astype(str):
            if v == "RISK_ON":
                # bright green similar to entry bar color
                out.append("background-color:#0a0; color:#fff; font-weight:700; text-align:center; border:1px solid #0b6f0b;")
            elif v == "RISK_OFF":
                out.append("background-color:#b00000; color:#fff; font-weight:700; text-align:center; border:1px solid #7a0000;")
            else:
                out.append("text-align:center;")
        return out

    # Colored badges for Signal: BUY=green, SELL=red, HOLD=orange, NO TRADE=grey
    def signal_badges(s):
        out=[]
        for v in s.astype(str):
            if v == "BUY":
                out.append("background-color:#0a0; color:#fff; font-weight:700; text-align:center; border:1px solid #0b6f0b;")
            elif v == "SELL":
                out.append("background-color:#b00000; color:#fff; font-weight:700; text-align:center; border:1px solid #7a0000;")
            elif v == "HOLD":
                out.append("background-color:#f59e0b; color:#1b1200; font-weight:700; text-align:center; border:1px solid #a86b06;")
            else:  # NO TRADE or anything else
                out.append("background-color:#3a3a3a; color:#eee; text-align:center; border:1px solid #2a2a2a;")
        return out

    # Keep some cells plain dark; Signal/Risk Gauge will be overridden by badge/box styles below
    plain_dark_cols = ["Rank","Token","Close"]

    styled = (
        df.style
        .set_caption(caption)
        .hide(axis="index")
        # Bars
        .apply(lambda s: bar_0_100(s, "#0a0"), subset=["Entry %","Confidence %"])
        .apply(lambda s: bar_0_100(s, "#0aa"), subset=["Suggested Wt %"])
        # Numeric green/red
        .apply(green_if_pos_red_if_neg, subset=["3d Return","7d Return","14d Return","Vol. Trend","Momentum","Sharpe 7d","EMA Diff"])
        .apply(lambda s: green_if_over(s, 50), subset=["RSI Short"])
        .apply(lambda s: green_if_over(s, 50), subset=["RSI Med"])
        # Base dark for some columns
        .set_properties(subset=plain_dark_cols, **{"background-color":"#0b0b0b","color":"#ddd","border-color":"#333"})
        # Apply colored badges (ensure these come AFTER set_properties to override)
        .apply(signal_badges, subset=["Signal"])
        .apply(risk_gauge_boxes, subset=["Risk Gauge"])
        # Score subtle shading
        .background_gradient(axis=None, cmap="Greens", subset=["Score"])
        # Black/white header & nicer typography
        .set_table_styles([
            {"selector":"table","props":[
                ("background-color","#181818"),("color","#ddd"),
                ("border-collapse","separate"),("border-spacing","0"),
                ("font-family","-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,'Helvetica Neue',Arial,'Noto Sans','Liberation Sans',sans-serif"),
                ("font-size","13px"),("line-height","1.35"),
                ("font-variant-numeric","tabular-nums lining-nums"),
                ("border","1px solid #2a2a2a"),("border-radius","10px"),("overflow","hidden")
            ]},
            {"selector":"th","props":[
                ("background-color","#000"),("color","#fff"),
                ("text-transform","uppercase"),("letter-spacing","0.02em"),
                ("font-weight","700"),("padding","8px 10px"),("border-bottom","1px solid #333")
            ]},
            {"selector":"caption","props":[
                ("caption-side","top"),("background-color","#000"),("color","#fff"),
                ("font-weight","600"),("font-size","14px"),("padding","10px 12px"),("text-align","left")
            ]},
            {"selector":"td","props":[
                ("padding","7px 10px"),("border-bottom","1px solid #242424"),
                ("border-right","1px solid #202020"),("vertical-align","middle")
            ]},
            {"selector":"td:last-child","props":[("border-right","none")]},
        ])
        .format({
            "Rank":"{:d}",
            "Score":"{:.2f}",
            "Entry %":"{:.1f}%",
            "Confidence %":"{:.1f}%",
            "Suggested Wt %":"{:.1f}%",
            "3d Return":"{:+.2f}%",
            "7d Return":"{:+.2f}%",
            "14d Return":"{:+.2f}%",
            "RSI Short":"{:.2f}",
            "RSI Med":"{:.2f}",
            "Vol. Trend":"{:+.2f}",
            "Momentum":"{:+.2f}",
            "Sharpe 7d":"{:.2f}",
            "EMA Diff":"{:+.2f}%",
            "Close":"{:.6f}"
        })
    )
    return styled

def save_html(styled, path):
    with open(path, "w", encoding="utf-8") as f:
        f.write(styled.to_html())

# ============================= MAIN =============================
def main():
    log("Downloading daily data from CryptoCompare â€¦")
    frames = load_universe(MEME_TICKERS, start=LOOKBACK_START)
    C,H,L,V,VT = align_panel(frames)
    coverage = C.notna().mean().mean()
    log(f"Average price coverage across kept symbols: {coverage*100:.1f}%")

    # ---- Today table
    table, meta = build_table_today(C,H,L,V,VT)
    table.to_csv(OUT_CSV, index=False)
    styled = style_table(table, meta)
    save_html(styled, OUT_HTML)

    # ---- Backtest + chart (2021 -> today by default)
    if RUN_BACKTEST:
        eq, btc_eq, stats = backtest(C,H,L,V,VT, start=BACKTEST_START, end=BACKTEST_END)
        print("\n===== BACKTEST ({} â†’ {}) =====".format(
            BACKTEST_START, (BACKTEST_END or str(eq.index[-1].date()))
        ))
        print(f"Total Return: {stats['TotalReturn']*100:.2f}%")
        print(f"CAGR:         {stats['CAGR']*100:.2f}%")
        print(f"Sharpe:       {stats['Sharpe']:.2f}")
        print(f"Sortino:      {stats['Sortino']:.2f}")
        print(f"Max Drawdown: {stats['MaxDD']*100:.2f}%")

        try:
            import matplotlib.pyplot as plt
            plt.figure(figsize=(11,5.8))
            plt.plot(eq.index, eq.values, label="RSPS (hybrid)")
            if btc_eq is not None:
                plt.plot(eq.index, btc_eq.reindex(eq.index).values, label="BTC HODL")
            plt.yscale("log")
            plt.title(f"RSPS vs BTC (log scale) â€” {BACKTEST_START} â†’ {eq.index[-1].date()}")
            plt.xlabel("Date"); plt.ylabel("Equity (log)")

            # Stats textbox
            box = (
                f"Total: {stats['TotalReturn']*100:.1f}%\n"
                f"CAGR:  {stats['CAGR']*100:.1f}%\n"
                f"Sharpe:{stats['Sharpe']:.2f}\n"
                f"Sort.: {stats['Sortino']:.2f}\n"
                f"MaxDD: {stats['MaxDD']*100:.1f}%"
            )
            plt.legend()
            plt.gcf().text(0.78, 0.50, box, fontsize=10,
                           bbox=dict(boxstyle="round", facecolor="#111", edgecolor="#444"),
                           color="#ddd")
            plt.tight_layout()
            plt.savefig(OUT_PNG, dpi=150)
            log(f"Saved chart -> {OUT_PNG}")
        except Exception as e:
            log(f"Chart skipped: {e} (install matplotlib)")

    if OPEN_AFTER_SAVE:
        try: webbrowser.open(f"file://{os.path.abspath(OUT_HTML)}")
        except Exception as e: log(f"Could not open browser: {e}")

    print("\n===== Meme Screener â€”", meta['today'].date(), "=====")
    print(f"Breadth (Entry%â‰¥{ENTRY_OK_THRESHOLD:.0f}%): {meta['breadth']:.1f}%  |  Exposure: {meta['exposure']*100:.0f}%  |  Total Alloc: {meta['alloc_sum']:.1f}%")
    print(table.to_string(index=False))
    print("\nSaved:", OUT_CSV, "|", OUT_HTML, "|", (OUT_PNG if RUN_BACKTEST else ""))

if __name__ == "__main__":
    main()





























